import numpy as np
import pandas as pd
import torch
from torch import nn, optim
import tensorflow as tf
from torchmetrics.classification import BinaryAccuracy

# Local application/library specific imports
import secretflow as sf
from secretflow.data.split import train_test_split
from secretflow.ml.nn import SLModel
from secretflow.ml.nn.fl.utils import metric_wrapper
from secretflow.ml.nn.sl.attacks.exploitattack_torch import ExploitAttack
from secretflow.ml.nn.utils import BaseModule, TorchModel
from secretflow.preprocessing import StandardScaler
from secretflow.utils.simulation.datasets import load_credicard

sf.shutdown()
sf.init(['alice', 'bob'], address='local', debug_mode=True)
alice, bob = sf.PYU('alice'), sf.PYU('bob')


num_samples = 10000
data = load_credicard({alice: (0, 29)})
label = load_credicard({bob: (29, 30)}).astype(np.float32)
scaler = StandardScaler()
data = scaler.fit_transform(data).astype(np.float32)
random_state = 1234
train_data, test_data = train_test_split(
    data, train_size=0.8, random_state=random_state
)
train_label, test_label = train_test_split(
    label, train_size=0.8, random_state=random_state
)
hidden_dim_1 = 16
hidden_dim_2 = 4

train_data = test_data
train_label = test_label


class BaseModel(BaseModule):
    def __init__(self):
        super(BaseModel, self).__init__()
        self.model = nn.Sequential(
            nn.Linear(29, 16),
            nn.ReLU(),
            nn.Linear(16, 16),
            nn.ReLU(),
        )

    def forward(self, x):
        return self.model(x)

    def output_num(self):
        return 1


class FuseModel(BaseModule):
    def __init__(self):
        super(FuseModel, self).__init__()
        self.dense_output = nn.Linear(16, 1)
        self.sigmoid = nn.Sigmoid()

    def forward(self, x):
        x = self.dense_output(x)
        x = self.sigmoid(x)
        return x


def create_surrogate_pytorch_model(
    input_dim, output_dim, party_nums, name="surrogate_model"
):
    import torch.nn as nn

    class BinaryClassifier(nn.Module):
        def __init__(self, input_dim, output_dim):
            super(BinaryClassifier, self).__init__()
            self.layer1 = nn.Linear(input_dim, 64)
            self.relu = nn.ReLU()
            self.layer2 = nn.Linear(64, output_dim)
            self.sigmoid = nn.Sigmoid()

        def forward(self, x):
            x = self.layer1(x)
            x = self.relu(x)
            x = self.layer2(x)
            x = self.sigmoid(x)
            return x

    def create_model():
        model = BinaryClassifier(input_dim, output_dim)
        return model

    return create_model


base_model = TorchModel(
    model_fn=BaseModel,
    loss_fn=nn.BCELoss,
    optim_fn=optim.Adam,
    metrics=[
        metric_wrapper(BinaryAccuracy),
    ],
)
base_model_dict = {
    alice: base_model,
}
fuse_model = TorchModel(
    model_fn=FuseModel,
    loss_fn=nn.BCELoss,
    optim_fn=optim.Adam,
    metrics=[
        metric_wrapper(BinaryAccuracy),
    ],
)
surrogate_builder = create_surrogate_pytorch_model(
    input_dim=hidden_dim_1, party_nums=2, output_dim=1
)
sl_model = SLModel(
    base_model_dict=base_model_dict,
    device_y=bob,
    model_fuse=fuse_model,
    simulation=True,
    random_seed=1234,
    backend="torch",
    strategy="split_nn",
)

label = sf.reveal(train_label.partitions[bob].data)
raw_df_neg = label[label["Class"] == 0]
raw_df_pos = label[label["Class"] == 1]

down_df_neg = raw_df_neg  # .sample(40000)
down_df = pd.concat([down_df_neg, raw_df_pos])

neg, pos = np.bincount(down_df["Class"])
total = neg + pos
print(
    "Examples:\n    Total: {}\n    Positive: {} ({:.2f}% of total)\n".format(
        total, pos, 100 * pos / total
    )
)

pos = torch.tensor(
    pos
)  # Assuming pos is defined and is a tensor or convertible to a tensor
total = torch.tensor(
    total
)  # Assuming total is defined and is a tensor or convertible to a tensor

p_pos = pos / total
p_values = torch.tensor([1 - p_pos, p_pos], dtype=torch.float32)

H_y = -p_pos * torch.log(p_pos) - (1 - p_pos) * torch.log(1 - p_pos)
y_pri = p_values.unsqueeze(0)  # Adds an extra dimension at axis 0

attack_cb = ExploitAttack(
    alice,
    10,
    epochs=1,
    batch_size=256,
    y_label=label,
    y_pri=y_pri,
    H_y=H_y,
    surrogate_model=surrogate_builder,
)
history = sl_model.fit(
    train_data,
    train_label,
    validation_data=(test_data, test_label),
    epochs=1,
    batch_size=256,
    shuffle=False,
    random_seed=1234,
    callbacks=[attack_cb],
)
