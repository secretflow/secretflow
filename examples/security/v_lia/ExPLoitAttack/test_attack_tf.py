import numpy as np
import pandas as pd
import torch

import secretflow as sf
from secretflow.data.split import train_test_split
from secretflow.ml.nn import SLModel
from secretflow.ml.nn.sl.attacks.exploitattack_tf import ExploitAttack
from secretflow.preprocessing import StandardScaler
from secretflow.utils.simulation.datasets import load_credicard

sf.shutdown()
sf.init(['alice', 'bob'], address='local', debug_mode=True)
alice, bob = sf.PYU('alice'), sf.PYU('bob')


num_samples = 10000
data = load_credicard({alice: (0, 29)})
label = load_credicard({bob: (29, 30)}).astype(np.float32)
scaler = StandardScaler()
data = scaler.fit_transform(data).astype(np.float32)
random_state = 1234
train_data, test_data = train_test_split(
    data, train_size=0.8, random_state=random_state
)
train_label, test_label = train_test_split(
    label, train_size=0.8, random_state=random_state
)
hidden_dim_1 = 16
hidden_dim_2 = 4

train_data = test_data
train_label = test_label


def create_base_net(input_dim, hidden_dim, name="first_net"):
    # Create model
    def create_model():
        import tensorflow as tf
        from tensorflow import keras
        from tensorflow.keras import layers

        model = keras.Sequential(
            [
                keras.Input(shape=input_dim),
                layers.Dense(hidden_dim // 2, activation="relu"),
                layers.Dense(hidden_dim, activation="relu"),
            ],
            name=name,
        )
        # Compile model
        model.summary()
        optimizer = tf.keras.optimizers.Adam()
        model.compile(
            loss="binary_crossentropy",
            optimizer=optimizer,
            metrics=["accuracy", tf.keras.metrics.AUC()],
        )
        return model

    return create_model


def create_fuse_model(input_dim_1, output_dim, party_nums, name="fuse_model"):
    def create_model():
        import tensorflow as tf
        from tensorflow import keras
        from tensorflow.keras import layers

        # input
        input_layers = keras.Input(
            input_dim_1,
        )

        output = layers.Dense(output_dim, activation="sigmoid")(input_layers)

        model = keras.Model(
            inputs=input_layers,
            outputs=output,
            name=name,
        )
        model.summary()

        optimizer = tf.keras.optimizers.Adam()

        model.compile(
            loss="binary_crossentropy",
            optimizer=optimizer,
            metrics=["accuracy", tf.keras.metrics.AUC()],
        )
        return model

    return create_model


def create_surrogate_model(input_dim, output_dim, party_nums, name="surrogate_model"):
    def create_model():
        import tensorflow as tf
        from tensorflow import keras
        from tensorflow.keras import layers

        model = keras.Sequential(
            [
                keras.Input(shape=input_dim),
                layers.Dense(64, activation="relu"),
                layers.Dense(output_dim, activation="sigmoid"),
            ],
            name=name,
        )
        model.summary()

        optimizer = tf.keras.optimizers.Adam()

        model.compile(
            loss="binary_crossentropy",
            optimizer=optimizer,
            metrics=["accuracy", tf.keras.metrics.AUC()],
        )
        return model

    return create_model


def create_surrogate_pytorch_model(
    input_dim, output_dim, party_nums, name="surrogate_model"
):
    import torch
    import torch.nn as nn
    import torch.optim as optim

    class BinaryClassifier(nn.Module):
        def __init__(self, input_dim, output_dim):
            super(BinaryClassifier, self).__init__()
            self.layer1 = nn.Linear(input_dim, 64)
            self.relu = nn.ReLU()
            self.layer2 = nn.Linear(64, output_dim)
            self.sigmoid = nn.Sigmoid()

        def forward(self, x):
            x = self.layer1(x)
            x = self.relu(x)
            x = self.layer2(x)
            x = self.sigmoid(x)
            return x

    def create_model():
        model = BinaryClassifier(input_dim, output_dim)
        return model

    return create_model


base_model_dict = {
    alice: create_base_net(input_dim=29, hidden_dim=hidden_dim_1),
}
fuse_model = create_fuse_model(input_dim_1=hidden_dim_1, party_nums=2, output_dim=1)
surrogate_builder = create_surrogate_model(
    input_dim=hidden_dim_1, party_nums=2, output_dim=1
)
sl_model = SLModel(
    base_model_dict=base_model_dict,
    device_y=bob,
    model_fuse=fuse_model,
    simulation=True,
    random_seed=1234,
    strategy="split_nn",
)

label = sf.reveal(train_label.partitions[bob].data)
raw_df_neg = label[label["Class"] == 0]
raw_df_pos = label[label["Class"] == 1]

down_df_neg = raw_df_neg  # .sample(40000)
down_df = pd.concat([down_df_neg, raw_df_pos])

neg, pos = np.bincount(down_df["Class"])
total = neg + pos
print(
    "Examples:\n    Total: {}\n    Positive: {} ({:.2f}% of total)\n".format(
        total, pos, 100 * pos / total
    )
)


pos = torch.tensor(
    pos
)  # Assuming pos is defined and is a tensor or convertible to a tensor
total = torch.tensor(
    total
)  # Assuming total is defined and is a tensor or convertible to a tensor

p_pos = pos / total
p_values = torch.tensor([1 - p_pos, p_pos], dtype=torch.float32)

H_y = -p_pos * torch.log(p_pos) - (1 - p_pos) * torch.log(1 - p_pos)
y_pri = p_values.unsqueeze(0)  # Adds an extra dimension at axis 0

attack_cb = ExploitAttack(
    alice,
    10,
    epochs=1,
    batch_size=256,
    y_label=label,
    y_pri=y_pri,
    H_y=H_y,
    surrogate_model=surrogate_builder,
)
history = sl_model.fit(
    train_data,
    train_label,
    validation_data=(test_data, test_label),
    epochs=1,
    batch_size=256,
    shuffle=False,
    random_seed=1234,
    callbacks=[attack_cb],
)
