{
  "name": "secretflow",
  "desc": "First-party SecretFlow components.",
  "version": "0.0.1",
  "comps": [
    {
      "domain": "data_filter",
      "name": "condition_filter",
      "desc": "Filter the table based on a single column's values and condition.\nWarning: the party responsible for condition filtering will directly send the sample distribution to other participants.\nMalicious participants can obtain the distribution of characteristics by repeatedly calling with different filtering values.\nAudit the usage of this component carefully.",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "comparator",
          "desc": "Comparator to use for comparison. Must be one of '==','<','<=','>','>=','IN'",
          "type": "AT_STRING",
          "atomic": {
            "allowedValues": {
              "ss": [
                "==",
                "<",
                "<=",
                ">",
                ">=",
                "IN"
              ]
            }
          }
        },
        {
          "name": "value_type",
          "desc": "Type of the value to compare with. Must be one of ['STRING', 'FLOAT']",
          "type": "AT_STRING",
          "atomic": {
            "allowedValues": {
              "ss": [
                "STRING",
                "FLOAT"
              ]
            }
          }
        },
        {
          "name": "bound_value",
          "desc": "Input a str with values separated by ','. List of values to compare with. If comparator is not 'IN', we only support one element in this list.",
          "type": "AT_STRING",
          "atomic": {}
        },
        {
          "name": "float_epsilon",
          "desc": "Epsilon value for floating point comparison. WARNING: due to floating point representation in computers, set this number slightly larger if you want filter out the values exactly at desired boundary. for example, abs(1.001 - 1.002) is slightly larger than 0.001, and therefore may not be filter out using == and epsilson = 0.001",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 1e-06
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          }
        }
      ],
      "inputs": [
        {
          "name": "in_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "features",
              "desc": "Feature(s) to operate on.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "out_ds",
          "desc": "Output vertical table that satisfies the condition.",
          "types": [
            "sf.table.vertical_table"
          ]
        },
        {
          "name": "out_ds_else",
          "desc": "Output vertical table that does not satisfies the condition.",
          "types": [
            "sf.table.vertical_table"
          ]
        }
      ]
    },
    {
      "domain": "data_filter",
      "name": "feature_filter",
      "desc": "Drop features from the dataset.",
      "version": "0.0.1",
      "inputs": [
        {
          "name": "in_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "drop_features",
              "desc": "Features to drop."
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "out_ds",
          "desc": "Output vertical table.",
          "types": [
            "sf.table.vertical_table"
          ]
        }
      ]
    },
    {
      "domain": "data_prep",
      "name": "psi",
      "desc": "PSI between two parties.",
      "version": "0.0.2",
      "attrs": [
        {
          "name": "protocol",
          "desc": "PSI protocol.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "PROTOCOL_RR22"
            },
            "allowedValues": {
              "ss": [
                "PROTOCOL_RR22",
                "PROTOCOL_ECDH",
                "PROTOCOL_KKRT"
              ]
            }
          }
        },
        {
          "name": "disable_alignment",
          "desc": "It true, output is not promised to be aligned. Warning: enable this option may lead to errors in the following components. DO NOT TURN ON if you want to append other components.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "name": "skip_duplicates_check",
          "desc": "If true, the check of duplicated items will be skiped.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "name": "check_hash_digest",
          "desc": "Check if hash digest of keys from parties are equal to determine whether to early-stop.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "name": "advanced_join_type",
          "desc": "Advanced Join allow duplicate keys.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "ADVANCED_JOIN_TYPE_UNSPECIFIED"
            },
            "allowedValues": {
              "ss": [
                "ADVANCED_JOIN_TYPE_UNSPECIFIED",
                "ADVANCED_JOIN_TYPE_INNER_JOIN",
                "ADVANCED_JOIN_TYPE_LEFT_JOIN",
                "ADVANCED_JOIN_TYPE_RIGHT_JOIN",
                "ADVANCED_JOIN_TYPE_FULL_JOIN",
                "ADVANCED_JOIN_TYPE_DIFFERENCE"
              ]
            }
          }
        },
        {
          "name": "left_side",
          "desc": "Required if advanced_join_type is selected.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "ROLE_RECEIVER"
            },
            "allowedValues": {
              "ss": [
                "ROLE_RECEIVER",
                "ROLE_SENDER"
              ]
            }
          }
        },
        {
          "name": "ecdh_curve",
          "desc": "Curve type for ECDH PSI.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "CURVE_FOURQ"
            },
            "allowedValues": {
              "ss": [
                "CURVE_25519",
                "CURVE_FOURQ",
                "CURVE_SM2",
                "CURVE_SECP256K1"
              ]
            }
          }
        }
      ],
      "inputs": [
        {
          "name": "receiver_input",
          "desc": "Individual table for receiver",
          "types": [
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "key",
              "desc": "Column(s) used to join.",
              "colMinCntInclusive": "1"
            }
          ]
        },
        {
          "name": "sender_input",
          "desc": "Individual table for sender",
          "types": [
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "key",
              "desc": "Column(s) used to join.",
              "colMinCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "psi_output",
          "desc": "Output vertical table",
          "types": [
            "sf.table.vertical_table"
          ]
        }
      ]
    },
    {
      "domain": "data_prep",
      "name": "train_test_split",
      "desc": "Split datasets into random train and test subsets.\n- Please check: https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "train_size",
          "desc": "Proportion of the dataset to include in the train subset. The sum of test_size and train_size should be in the (0, 1] range.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.75
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            }
          }
        },
        {
          "name": "test_size",
          "desc": "Proportion of the dataset to include in the test subset. The sum of test_size and train_size should be in the (0, 1] range.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.25
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            }
          }
        },
        {
          "name": "random_state",
          "desc": "Specify the random seed of the shuffling.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "1024"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          }
        },
        {
          "name": "shuffle",
          "desc": "Whether to shuffle the data before splitting.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          }
        }
      ],
      "inputs": [
        {
          "name": "input_data",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ]
        }
      ],
      "outputs": [
        {
          "name": "train",
          "desc": "Output train dataset.",
          "types": [
            "sf.table.vertical_table"
          ]
        },
        {
          "name": "test",
          "desc": "Output test dataset.",
          "types": [
            "sf.table.vertical_table"
          ]
        }
      ]
    },
    {
      "domain": "feature",
      "name": "vert_binning",
      "desc": "Generate equal frequency or equal range binning rules for vertical partitioning datasets.",
      "version": "0.0.2",
      "attrs": [
        {
          "name": "binning_method",
          "desc": "How to bin features with numeric types: \"quantile\"(equal frequency)/\"eq_range\"(equal range)",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "eq_range"
            },
            "allowedValues": {
              "ss": [
                "eq_range",
                "quantile"
              ]
            }
          }
        },
        {
          "name": "bin_num",
          "desc": "Max bin counts for one features.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "2"
            },
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "report_rules",
          "desc": "Whether report binning rules.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        }
      ],
      "inputs": [
        {
          "name": "input_data",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "which features should be binned.",
              "colMinCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "bin_rule",
          "desc": "Output bin rule.",
          "types": [
            "sf.rule.binning"
          ]
        },
        {
          "name": "report",
          "desc": "report rules details if report_rules is true",
          "types": [
            "sf.report"
          ]
        }
      ]
    },
    {
      "domain": "feature",
      "name": "vert_woe_binning",
      "desc": "Generate Weight of Evidence (WOE) binning rules for vertical partitioning datasets.",
      "version": "0.0.2",
      "attrs": [
        {
          "name": "secure_device_type",
          "desc": "Use SPU(Secure multi-party computation or MPC) or HEU(Homomorphic encryption or HE) to secure bucket summation.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "spu"
            },
            "allowedValues": {
              "ss": [
                "spu",
                "heu"
              ]
            }
          }
        },
        {
          "name": "binning_method",
          "desc": "How to bin features with numeric types: \"quantile\"(equal frequency)/\"chimerge\"(ChiMerge from AAAI92-019: https://www.aaai.org/Papers/AAAI/1992/AAAI92-019.pdf)/\"eq_range\"(equal range)",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "quantile"
            },
            "allowedValues": {
              "ss": [
                "quantile",
                "chimerge",
                "eq_range"
              ]
            }
          }
        },
        {
          "name": "bin_num",
          "desc": "Max bin counts for one features.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          }
        },
        {
          "name": "positive_label",
          "desc": "Which value represent positive value in label.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "1"
            }
          }
        },
        {
          "name": "chimerge_init_bins",
          "desc": "Max bin counts for initialization binning in ChiMerge.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "100"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "2"
            }
          }
        },
        {
          "name": "chimerge_target_bins",
          "desc": "Stop merging if remaining bin counts is less than or equal to this value.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "2"
            },
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "chimerge_target_pvalue",
          "desc": "Stop merging if biggest pvalue of remaining bins is greater than this value.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "report_rules",
          "desc": "Whether report binning rules.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        }
      ],
      "inputs": [
        {
          "name": "input_data",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "which features should be binned.",
              "colMinCntInclusive": "1"
            },
            {
              "name": "label",
              "desc": "Label of input data.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "bin_rule",
          "desc": "Output WOE rule.",
          "types": [
            "sf.rule.binning"
          ]
        },
        {
          "name": "report",
          "desc": "report rules details if report_rules is true",
          "types": [
            "sf.report"
          ]
        }
      ]
    },
    {
      "domain": "io",
      "name": "identity",
      "desc": "map any input to output",
      "version": "0.0.1",
      "inputs": [
        {
          "name": "input_data",
          "desc": "Input data",
          "types": [
            "sf.model.ss_glm",
            "sf.model.sgb",
            "sf.model.ss_xgb",
            "sf.model.ss_sgd",
            "sf.rule.binning",
            "sf.rule.preprocessing",
            "sf.read_data"
          ]
        }
      ],
      "outputs": [
        {
          "name": "output_data",
          "desc": "Output data",
          "types": [
            "sf.model.ss_glm",
            "sf.model.sgb",
            "sf.model.ss_xgb",
            "sf.model.ss_sgd",
            "sf.rule.binning",
            "sf.rule.preprocessing",
            "sf.read_data"
          ]
        }
      ]
    },
    {
      "domain": "io",
      "name": "read_data",
      "desc": "read model or rules from sf cluster",
      "version": "0.0.1",
      "inputs": [
        {
          "name": "input_dd",
          "desc": "Input dist data",
          "types": [
            "sf.rule.binning",
            "sf.model.ss_glm"
          ]
        }
      ],
      "outputs": [
        {
          "name": "output_data",
          "desc": "Output rules or models in DistData.meta",
          "types": [
            "sf.read_data"
          ]
        }
      ]
    },
    {
      "domain": "io",
      "name": "write_data",
      "desc": "write model or rules back to sf cluster",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "write_data",
          "desc": "rule or model protobuf by json formate",
          "type": "AT_STRING",
          "atomic": {}
        },
        {
          "name": "write_data_type",
          "desc": "which rule or model is writing",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "sf.rule.binning"
            },
            "allowedValues": {
              "ss": [
                "sf.rule.binning",
                "sf.model.ss_glm"
              ]
            }
          }
        }
      ],
      "inputs": [
        {
          "name": "input_dd",
          "desc": "Input dist data. Rule reconstructions may need hidden info in original rule for security considerations.",
          "types": [
            "sf.rule.binning",
            "sf.model.ss_glm"
          ]
        }
      ],
      "outputs": [
        {
          "name": "output_model",
          "desc": "Output rules or models in sf cluster format",
          "types": [
            "sf.rule.binning",
            "sf.model.ss_glm"
          ]
        }
      ]
    },
    {
      "domain": "ml.eval",
      "name": "biclassification_eval",
      "desc": "Statistics evaluation for a bi-classification model on a dataset.\n1. summary_report: SummaryReport\n2. group_reports: List[GroupReport]\n3. eq_frequent_bin_report: List[EqBinReport]\n4. eq_range_bin_report: List[EqBinReport]\n5. head_report: List[PrReport]\nreports for fpr = 0.001, 0.005, 0.01, 0.05, 0.1, 0.2",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "bucket_size",
          "desc": "Number of buckets.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "min_item_cnt_per_bucket",
          "desc": "Min item cnt per bucket. If any bucket doesn't meet the requirement, error raises. For security reasons, we require this parameter to be at least 5.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "5"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "5"
            },
            "lowerBoundInclusive": true
          }
        }
      ],
      "inputs": [
        {
          "name": "in_ds",
          "desc": "Input table with prediction and label, usually is a result from a prediction component.",
          "types": [
            "sf.table.vertical_table",
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "label",
              "desc": "The label name to use in the dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            },
            {
              "name": "prediction",
              "desc": "The prediction result column name to use in the dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "reports",
          "desc": "Output report.",
          "types": [
            "sf.report"
          ]
        }
      ]
    },
    {
      "domain": "ml.eval",
      "name": "prediction_bias_eval",
      "desc": "Calculate prediction bias, ie. average of predictions - average of labels.",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "bucket_num",
          "desc": "Num of bucket.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "min_item_cnt_per_bucket",
          "desc": "Min item cnt per bucket. If any bucket doesn't meet the requirement, error raises. For security reasons, we require this parameter to be at least 2.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "2"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "2"
            },
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "bucket_method",
          "desc": "Bucket method.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "equal_width"
            },
            "allowedValues": {
              "ss": [
                "equal_width",
                "equal_frequency"
              ]
            }
          }
        }
      ],
      "inputs": [
        {
          "name": "in_ds",
          "desc": "Input table with prediction and label, usually is a result from a prediction component.",
          "types": [
            "sf.table.vertical_table",
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "label",
              "desc": "The label name to use in the dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            },
            {
              "name": "prediction",
              "desc": "The prediction result column name to use in the dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "result",
          "desc": "Output report.",
          "types": [
            "sf.report"
          ]
        }
      ]
    },
    {
      "domain": "ml.eval",
      "name": "regression_eval",
      "desc": "Statistics evaluation for a regression model on a dataset.\nContained Statistics:\nR2 Score (r2_score): It is a statistical measure that represents the proportion of the variance in the dependent variable that can be predicted from the independent variables. It ranges from 0 to 1, where a higher value indicates a better fit.\nMean Absolute Error (mean_abs_err): It calculates the average absolute difference between the predicted and actual values. It provides a measure of the average magnitude of the errors.\nMean Absolute Percentage Error (mean_abs_percent_err): It calculates the average absolute percentage difference between the predicted and actual values. It measures the average magnitude of the errors in terms of percentages.\nSum of Squared Errors (sum_squared_errors): It calculates the sum of the squared differences between the predicted and actual values. It provides an overall measure of the model's performance.\nMean Squared Error (mean_squared_errors): It calculates the average of the squared differences between the predicted and actual values. It is widely used as a loss function in regression problems.\nRoot Mean Squared Error (root_mean_squared_errors): It is the square root of the mean squared error. It provides a measure of the average magnitude of the errors in the original scale of the target variable.\nMean of True Values (y_true_mean): It calculates the average of the actual values in the target variable. It can be useful for establishing a baseline for the model's performance.\nMean of Predicted Values (y_pred_mean): It calculates the average of the predicted values. It can be compared with the y_true_mean to get an idea of the model's bias.\nResidual Histograms (residual_hists): It represents the distribution of the differences between the predicted and actual values. It helps to understand the spread and pattern of the errors.",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "bucket_size",
          "desc": "Number of buckets for residual histogram.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "10000"
            },
            "upperBoundInclusive": true
          }
        }
      ],
      "inputs": [
        {
          "name": "in_ds",
          "desc": "Input table with prediction and label, usually is a result from a prediction component.",
          "types": [
            "sf.table.vertical_table",
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "label",
              "desc": "The label name to use in the dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            },
            {
              "name": "prediction",
              "desc": "The prediction result column name to use in the dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "reports",
          "desc": "Output report.",
          "types": [
            "sf.report"
          ]
        }
      ]
    },
    {
      "domain": "ml.eval",
      "name": "ss_pvalue",
      "desc": "Calculate P-Value for LR model training on vertical partitioning dataset by using secret sharing.\nFor large dataset(large than 10w samples & 200 features),\nrecommend to use [Ring size: 128, Fxp: 40] options for SPU device.",
      "version": "0.0.1",
      "inputs": [
        {
          "name": "model",
          "desc": "Input model.",
          "types": [
            "sf.model.ss_sgd"
          ]
        },
        {
          "name": "input_data",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ]
        }
      ],
      "outputs": [
        {
          "name": "report",
          "desc": "Output P-Value report.",
          "types": [
            "sf.report"
          ]
        }
      ]
    },
    {
      "domain": "ml.predict",
      "name": "sgb_predict",
      "desc": "Predict using SGB model.",
      "version": "0.0.2",
      "attrs": [
        {
          "name": "receiver",
          "desc": "Party of receiver.",
          "type": "AT_STRING",
          "atomic": {}
        },
        {
          "name": "pred_name",
          "desc": "Name for prediction column",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "pred"
            }
          }
        },
        {
          "name": "save_ids",
          "desc": "Whether to save ids columns into output prediction table. If true, input feature_dataset must contain id columns, and receiver party must be id owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "name": "save_label",
          "desc": "Whether or not to save real label columns into output pred file. If true, input feature_dataset must contain label columns and receiver party must be label owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          }
        }
      ],
      "inputs": [
        {
          "name": "model",
          "desc": "model",
          "types": [
            "sf.model.sgb"
          ]
        },
        {
          "name": "feature_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ]
        }
      ],
      "outputs": [
        {
          "name": "pred",
          "desc": "Output prediction.",
          "types": [
            "sf.table.individual"
          ]
        }
      ]
    },
    {
      "domain": "ml.predict",
      "name": "ss_glm_predict",
      "desc": "Predict using the SSGLM model.",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "receiver",
          "desc": "Party of receiver.",
          "type": "AT_STRING",
          "atomic": {}
        },
        {
          "name": "pred_name",
          "desc": "Column name for predictions.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "pred"
            }
          }
        },
        {
          "name": "save_ids",
          "desc": "Whether to save ids columns into output prediction table. If true, input feature_dataset must contain id columns, and receiver party must be id owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          }
        },
        {
          "name": "save_label",
          "desc": "Whether or not to save real label columns into output pred file. If true, input feature_dataset must contain label columns and receiver party must be label owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        }
      ],
      "inputs": [
        {
          "name": "model",
          "desc": "Input model.",
          "types": [
            "sf.model.ss_glm"
          ]
        },
        {
          "name": "feature_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "saved_features",
              "desc": "which features should be saved with prediction result"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "pred",
          "desc": "Output prediction.",
          "types": [
            "sf.table.individual"
          ]
        }
      ]
    },
    {
      "domain": "ml.predict",
      "name": "ss_sgd_predict",
      "desc": "Predict using the SS-SGD model.",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "batch_size",
          "desc": "The number of training examples utilized in one iteration.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "1024"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          }
        },
        {
          "name": "receiver",
          "desc": "Party of receiver.",
          "type": "AT_STRING",
          "atomic": {}
        },
        {
          "name": "pred_name",
          "desc": "Column name for predictions.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "pred"
            }
          }
        },
        {
          "name": "save_ids",
          "desc": "Whether to save ids columns into output prediction table. If true, input feature_dataset must contain id columns, and receiver party must be id owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          }
        },
        {
          "name": "save_label",
          "desc": "Whether or not to save real label columns into output pred file. If true, input feature_dataset must contain label columns and receiver party must be label owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        }
      ],
      "inputs": [
        {
          "name": "model",
          "desc": "Input model.",
          "types": [
            "sf.model.ss_sgd"
          ]
        },
        {
          "name": "feature_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "saved_features",
              "desc": "which features should be saved with prediction result"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "pred",
          "desc": "Output prediction.",
          "types": [
            "sf.table.individual"
          ]
        }
      ]
    },
    {
      "domain": "ml.predict",
      "name": "ss_xgb_predict",
      "desc": "Predict using the SS-XGB model.",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "receiver",
          "desc": "Party of receiver.",
          "type": "AT_STRING",
          "atomic": {}
        },
        {
          "name": "pred_name",
          "desc": "Column name for predictions.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "pred"
            }
          }
        },
        {
          "name": "save_ids",
          "desc": "Whether to save ids columns into output prediction table. If true, input feature_dataset must contain id columns, and receiver party must be id owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          }
        },
        {
          "name": "save_label",
          "desc": "Whether or not to save real label columns into output pred file. If true, input feature_dataset must contain label columns and receiver party must be label owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        }
      ],
      "inputs": [
        {
          "name": "model",
          "desc": "Input model.",
          "types": [
            "sf.model.ss_xgb"
          ]
        },
        {
          "name": "feature_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "saved_features",
              "desc": "which features should be saved with prediction result"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "pred",
          "desc": "Output prediction.",
          "types": [
            "sf.table.individual"
          ]
        }
      ]
    },
    {
      "domain": "ml.train",
      "name": "sgb_train",
      "desc": "Provides both classification and regression tree boosting (also known as GBDT, GBM)\nfor vertical split dataset setting by using secure boost.\n- SGB is short for SecureBoost. Compared to its safer counterpart SS-XGB, SecureBoost focused on protecting label holder.\n- Check https://arxiv.org/abs/1901.08755.",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "num_boost_round",
          "desc": "Number of boosting iterations.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "max_depth",
          "desc": "Maximum depth of a tree.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "5"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "16"
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "learning_rate",
          "desc": "Step size shrinkage used in update to prevent overfitting.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "objective",
          "desc": "Specify the learning objective.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "logistic"
            },
            "allowedValues": {
              "ss": [
                "linear",
                "logistic"
              ]
            }
          }
        },
        {
          "name": "reg_lambda",
          "desc": "L2 regularization term on weights.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 10000.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "gamma",
          "desc": "Greater than 0 means pre-pruning enabled. If gain of a node is less than this value, it would be pruned.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 10000.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "colsample_by_tree",
          "desc": "Subsample ratio of columns when constructing each tree.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 1.0
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "sketch_eps",
          "desc": "This roughly translates into O(1 / sketch_eps) number of bins.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "base_score",
          "desc": "The initial prediction score of all instances, global bias.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "seed",
          "desc": "Pseudorandom number generator seed.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "42"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "fixed_point_parameter",
          "desc": "Any floating point number encoded by heu, will multiply a scale and take the round, scale = 2 ** fixed_point_parameter. larger value may mean more numerical accuracy, but too large will lead to overflow problem.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "20"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "100"
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "first_tree_with_label_holder_feature",
          "desc": "Whether to train the first tree with label holder's own features.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "name": "batch_encoding_enabled",
          "desc": "If use batch encoding optimization.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          }
        },
        {
          "name": "enable_quantization",
          "desc": "Whether enable quantization of g and h.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "name": "quantization_scale",
          "desc": "Scale the sum of g to the specified value.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 10000.0
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 10000000.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "max_leaf",
          "desc": "Maximum leaf of a tree. Only effective if train leaf wise.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "15"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "32768"
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "rowsample_by_tree",
          "desc": "Row sub sample ratio of the training instances.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 1.0
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "enable_goss",
          "desc": "Whether to enable GOSS.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "name": "top_rate",
          "desc": "GOSS-specific parameter. The fraction of large gradients to sample.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.3
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "bottom_rate",
          "desc": "GOSS-specific parameter. The fraction of small gradients to sample.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.5
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "early_stop_criterion_g_abs_sum",
          "desc": "If sum(abs(g)) is lower than or equal to this threshold, training will stop.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "early_stop_criterion_g_abs_sum_change_ratio",
          "desc": "If absolute g sum change ratio is lower than or equal to this threshold, training will stop.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "tree_growing_method",
          "desc": "How to grow tree?",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "level"
            }
          }
        }
      ],
      "inputs": [
        {
          "name": "train_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "which features should be used for training.",
              "colMinCntInclusive": "1"
            },
            {
              "name": "label",
              "desc": "Label of train dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "output_model",
          "desc": "Output model.",
          "types": [
            "sf.model.sgb"
          ]
        }
      ]
    },
    {
      "domain": "ml.train",
      "name": "ss_glm_train",
      "desc": "generalized linear model (GLM) is a flexible generalization of ordinary linear regression.\nThe GLM generalizes linear regression by allowing the linear model to be related to the response\nvariable via a link function and by allowing the magnitude of the variance of each measurement to\nbe a function of its predicted value.",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "epochs",
          "desc": "The number of complete pass through the training data.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "learning_rate",
          "desc": "The step size at each iteration in one iteration.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          }
        },
        {
          "name": "batch_size",
          "desc": "The number of training examples utilized in one iteration.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "1024"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          }
        },
        {
          "name": "link_type",
          "desc": "link function type",
          "type": "AT_STRING",
          "atomic": {
            "allowedValues": {
              "ss": [
                "Logit",
                "Log",
                "Reciprocal",
                "Identity"
              ]
            }
          }
        },
        {
          "name": "label_dist_type",
          "desc": "label distribution type",
          "type": "AT_STRING",
          "atomic": {
            "allowedValues": {
              "ss": [
                "Bernoulli",
                "Poisson",
                "Gamma",
                "Tweedie"
              ]
            }
          }
        },
        {
          "name": "tweedie_power",
          "desc": "Tweedie distribution power parameter",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 1.0
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 2.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "dist_scale",
          "desc": "A guess value for distribution's scale",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 1.0
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "f": 1.0
            },
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "eps",
          "desc": "If the change rate of weights is less than this threshold, the model is considered to be converged, and the training stops early. 0 to disable.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.0001
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "iter_start_irls",
          "desc": "run a few rounds of IRLS training as the initialization of w, 0 disable",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "decay_epoch",
          "desc": "decay learning interval",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "decay_rate",
          "desc": "decay learning rate",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            }
          }
        },
        {
          "name": "optimizer",
          "desc": "which optimizer to use: IRLS(Iteratively Reweighted Least Squares) or SGD(Stochastic Gradient Descent)",
          "type": "AT_STRING",
          "atomic": {
            "allowedValues": {
              "ss": [
                "SGD",
                "IRLS"
              ]
            }
          }
        },
        {
          "name": "l2_lambda",
          "desc": "L2 regularization term",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "infeed_batch_size_limit",
          "desc": "size of a single block, default to 10w * 100. increase the size will increase memory cost, but may decrease running time. Suggested to be as large as possible. (too large leads to OOM)",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10000000"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1000"
            },
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "newton_iter",
          "desc": "number of rounds for newton matrix inverse iterations, increase may increase accuracy, but also increase running time. Suggested to be as small as possible. (too small or too large both lead to bad accuracy)",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "25"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "report_weights",
          "desc": "If this option is set to true, model will be revealed and model details are visible to all parties",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        }
      ],
      "inputs": [
        {
          "name": "train_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "which features should be used for training.",
              "colMinCntInclusive": "1"
            },
            {
              "name": "offset",
              "desc": "Specify a column to use as the offset",
              "colMaxCntInclusive": "1"
            },
            {
              "name": "weight",
              "desc": "Specify a column to use for the observation weights",
              "colMaxCntInclusive": "1"
            },
            {
              "name": "label",
              "desc": "Label of train dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "output_model",
          "desc": "Output model.",
          "types": [
            "sf.model.ss_glm"
          ]
        },
        {
          "name": "report",
          "desc": "If report_weights is true, report model details",
          "types": [
            "sf.report"
          ]
        }
      ]
    },
    {
      "domain": "ml.train",
      "name": "ss_sgd_train",
      "desc": "Train both linear and logistic regression\nlinear models for vertical partitioning dataset with mini batch SGD training solver by using secret sharing.\n- SS-SGD is short for secret sharing SGD training.",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "epochs",
          "desc": "The number of complete pass through the training data.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "learning_rate",
          "desc": "The step size at each iteration in one iteration.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          }
        },
        {
          "name": "batch_size",
          "desc": "The number of training examples utilized in one iteration.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "1024"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          }
        },
        {
          "name": "sig_type",
          "desc": "Sigmoid approximation type.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "t1"
            },
            "allowedValues": {
              "ss": [
                "real",
                "t1",
                "t3",
                "t5",
                "df",
                "sr",
                "mix"
              ]
            }
          }
        },
        {
          "name": "reg_type",
          "desc": "Regression type",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "logistic"
            },
            "allowedValues": {
              "ss": [
                "linear",
                "logistic"
              ]
            }
          }
        },
        {
          "name": "penalty",
          "desc": "The penalty(aka regularization term) to be used.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "None"
            },
            "allowedValues": {
              "ss": [
                "None",
                "l1",
                "l2"
              ]
            }
          }
        },
        {
          "name": "l2_norm",
          "desc": "L2 regularization term.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.5
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "eps",
          "desc": "If the change rate of weights is less than this threshold, the model is considered to be converged, and the training stops early. 0 to disable.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.001
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          }
        }
      ],
      "inputs": [
        {
          "name": "train_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "which features should be used for training.",
              "colMinCntInclusive": "1"
            },
            {
              "name": "label",
              "desc": "Label of train dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "output_model",
          "desc": "Output model.",
          "types": [
            "sf.model.ss_sgd"
          ]
        }
      ]
    },
    {
      "domain": "ml.train",
      "name": "ss_xgb_train",
      "desc": "This method provides both classification and regression tree boosting (also known as GBDT, GBM)\nfor vertical partitioning dataset setting by using secret sharing.\n- SS-XGB is short for secret sharing XGB.\n- More details: https://arxiv.org/pdf/2005.08479.pdf",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "num_boost_round",
          "desc": "Number of boosting iterations.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "max_depth",
          "desc": "Maximum depth of a tree.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "5"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "16"
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "learning_rate",
          "desc": "Step size shrinkage used in updates to prevent overfitting.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "objective",
          "desc": "Specify the learning objective.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "logistic"
            },
            "allowedValues": {
              "ss": [
                "linear",
                "logistic"
              ]
            }
          }
        },
        {
          "name": "reg_lambda",
          "desc": "L2 regularization term on weights.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 10000.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "subsample",
          "desc": "Subsample ratio of the training instances.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "colsample_by_tree",
          "desc": "Subsample ratio of columns when constructing each tree.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "sketch_eps",
          "desc": "This roughly translates into O(1 / sketch_eps) number of bins.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "base_score",
          "desc": "The initial prediction score of all instances, global bias.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "seed",
          "desc": "Pseudorandom number generator seed.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "42"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          }
        }
      ],
      "inputs": [
        {
          "name": "train_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "which features should be used for training.",
              "colMinCntInclusive": "1"
            },
            {
              "name": "label",
              "desc": "Label of train dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "output_model",
          "desc": "Output model.",
          "types": [
            "sf.model.ss_xgb"
          ]
        }
      ]
    },
    {
      "domain": "model",
      "name": "model_export",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "model_name",
          "desc": "model's name",
          "type": "AT_STRING",
          "atomic": {}
        },
        {
          "name": "model_desc",
          "desc": "Describe what the model does",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "name": "input_datasets",
          "desc": "all components' input data id",
          "type": "AT_STRINGS",
          "atomic": {
            "listMaxLengthInclusive": "-1"
          }
        },
        {
          "name": "output_datasets",
          "desc": "all components' output data id",
          "type": "AT_STRINGS",
          "atomic": {
            "listMaxLengthInclusive": "-1"
          }
        },
        {
          "name": "component_eval_params",
          "desc": "all components' params in json format",
          "type": "AT_STRINGS",
          "atomic": {
            "listMaxLengthInclusive": "-1"
          }
        }
      ],
      "outputs": [
        {
          "name": "package_output",
          "desc": "output tar package uri",
          "types": [
            "sf.serving.model"
          ]
        }
      ]
    },
    {
      "domain": "preprocessing",
      "name": "binary_op",
      "desc": "Perform binary operation binary_op(f1, f2) and assign the result to f3, f3 can be new or old. Currently f1, f2 and f3 all belong to a single party.",
      "version": "0.0.2",
      "attrs": [
        {
          "name": "binary_op",
          "desc": "What kind of binary operation we want to do, currently only supports +, -, *, /",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "+"
            },
            "allowedValues": {
              "ss": [
                "+",
                "-",
                "*",
                "/"
              ]
            }
          }
        },
        {
          "name": "new_feature_name",
          "desc": "Name of the newly generated feature.",
          "type": "AT_STRING",
          "atomic": {}
        },
        {
          "name": "as_label",
          "desc": "If True, the generated feature will be marked as label in schema.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        }
      ],
      "inputs": [
        {
          "name": "in_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "f1",
              "desc": "Feature 1 to operate on.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            },
            {
              "name": "f2",
              "desc": "Feature 2 to operate on.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "out_ds",
          "desc": "Output vertical table.",
          "types": [
            "sf.table.vertical_table"
          ]
        },
        {
          "name": "out_rules",
          "desc": "feature gen rule",
          "types": [
            "sf.rule.preprocessing"
          ]
        }
      ]
    },
    {
      "domain": "preprocessing",
      "name": "case_when",
      "desc": "case_when",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "rules",
          "desc": "input CaseWhen rules",
          "type": "AT_CUSTOM_PROTOBUF",
          "customProtobufCls": "case_when_rules_pb2.CaseWhenRule"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ]
        }
      ],
      "outputs": [
        {
          "name": "output_dataset",
          "desc": "output_dataset",
          "types": [
            "sf.table.vertical_table"
          ]
        },
        {
          "name": "out_rules",
          "desc": "case when substitution rule",
          "types": [
            "sf.rule.preprocessing"
          ]
        }
      ]
    },
    {
      "domain": "preprocessing",
      "name": "feature_calculate",
      "desc": "Generate a new feature by performing calculations on an origin feature",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "rules",
          "desc": "input CalculateOpRules rules",
          "type": "AT_CUSTOM_PROTOBUF",
          "customProtobufCls": "calculate_rules_pb2.CalculateOpRules"
        }
      ],
      "inputs": [
        {
          "name": "in_ds",
          "desc": "Input vertical table",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "features",
              "desc": "Feature(s) to operate on",
              "colMinCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "out_ds",
          "desc": "output_dataset",
          "types": [
            "sf.table.vertical_table"
          ]
        },
        {
          "name": "out_rules",
          "desc": "feature calculate rule",
          "types": [
            "sf.rule.preprocessing"
          ]
        }
      ]
    },
    {
      "domain": "preprocessing",
      "name": "fillna",
      "desc": "fillna",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "strategy",
          "desc": "The imputation strategy. If \"mean\", then replace missing values using the mean along each column. Can only be used with numeric data. If \"median\", then replace missing values using the median along each column. Can only be used with numeric data. If \"most_frequent\", then replace missing using the most frequent value along each column. Can be used with strings or numeric data. If there is more than one such value, only the smallest is returned. If \"constant\", then replace missing values with fill_value. Can be used with strings or numeric data.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "constant"
            },
            "allowedValues": {
              "ss": [
                "mean",
                "median",
                "most_frequent",
                "constant"
              ]
            }
          }
        },
        {
          "name": "missing_value_type",
          "desc": "type of missing value. general_na type indicates that only np.nan, None or pandas.NA will be treated as missing values. When the type is not general_na, the type casted missing_value_type(missing_value) will also be treated as missing value as well, in addition to general_na values.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "general_na"
            },
            "allowedValues": {
              "ss": [
                "general_na",
                "str",
                "int",
                "float"
              ]
            }
          }
        },
        {
          "name": "missing_value",
          "desc": "Which value should be treat as missing_value? If missing value type is 'general_na', this field will be ignored, and any np.nan, pd.NA, etc value will be treated as missing value. Otherwise, the type casted missing_value_type(missing_value) will also be treated as missing value as well, in addition to general_na values. In case the cast is not successful, general_na will be used instead. default value is 'custom_missing_value'.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "custom_missing_value"
            }
          }
        },
        {
          "name": "fill_value_int",
          "desc": "For int type data. If method is 'constant' use this value for filling null.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "name": "fill_value_float",
          "desc": "For float type data. If method is 'constant' use this value for filling null.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "name": "fill_value_str",
          "desc": "For str type data. If method is 'constant' use this value for filling null.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "fill_na_features",
              "desc": "Features to fill."
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "out_ds",
          "desc": "Output vertical table.",
          "types": [
            "sf.table.vertical_table"
          ]
        },
        {
          "name": "out_rules",
          "desc": "fill value rule",
          "types": [
            "sf.rule.preprocessing"
          ]
        }
      ]
    },
    {
      "domain": "preprocessing",
      "name": "onehot_encode",
      "desc": "onehot_encode",
      "version": "0.0.2",
      "attrs": [
        {
          "name": "drop_first",
          "desc": "If true drop the first category in each feature. If only one category is present, the feature will be dropped entirely",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "name": "min_frequency",
          "desc": "Specifies the minimum frequency below which a category will be considered infrequent, [0, 1), 0 disable",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            }
          }
        },
        {
          "name": "report_rules",
          "desc": "Whether to report rule details",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          }
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "features",
              "desc": "Features to encode."
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "output_dataset",
          "desc": "output_dataset",
          "types": [
            "sf.table.vertical_table"
          ]
        },
        {
          "name": "out_rules",
          "desc": "onehot rule",
          "types": [
            "sf.rule.preprocessing"
          ]
        },
        {
          "name": "report",
          "desc": "report rules details if report_rules is true",
          "types": [
            "sf.report"
          ]
        }
      ]
    },
    {
      "domain": "preprocessing",
      "name": "substitution",
      "desc": "unified substitution component",
      "version": "0.0.2",
      "inputs": [
        {
          "name": "input_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ]
        },
        {
          "name": "input_rules",
          "desc": "Input preprocessing rules",
          "types": [
            "sf.rule.preprocessing"
          ]
        }
      ],
      "outputs": [
        {
          "name": "output_dataset",
          "desc": "output_dataset",
          "types": [
            "sf.table.vertical_table"
          ]
        }
      ]
    },
    {
      "domain": "preprocessing",
      "name": "vert_bin_substitution",
      "desc": "Substitute datasets' value by bin substitution rules.",
      "version": "0.0.1",
      "inputs": [
        {
          "name": "input_data",
          "desc": "Vertical partitioning dataset to be substituted.",
          "types": [
            "sf.table.vertical_table"
          ]
        },
        {
          "name": "bin_rule",
          "desc": "Input bin substitution rule.",
          "types": [
            "sf.rule.binning"
          ]
        }
      ],
      "outputs": [
        {
          "name": "output_data",
          "desc": "Output vertical table.",
          "types": [
            "sf.table.vertical_table"
          ]
        }
      ]
    },
    {
      "domain": "stats",
      "name": "groupby_statistics",
      "desc": "Get a groupby of statistics, like pandas groupby statistics.\nCurrently only support VDataframe.",
      "version": "0.0.3",
      "attrs": [
        {
          "name": "aggregation_config",
          "desc": "input groupby aggregation config",
          "type": "AT_CUSTOM_PROTOBUF",
          "customProtobufCls": "groupby_aggregation_config_pb2.GroupbyAggregationConfig"
        },
        {
          "name": "max_group_size",
          "desc": "The maximum number of groups allowed",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10000"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "10001"
            }
          }
        }
      ],
      "inputs": [
        {
          "name": "input_data",
          "desc": "Input table.",
          "types": [
            "sf.table.vertical_table",
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "by",
              "desc": "by what columns should we group the values",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "4"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "report",
          "desc": "Output groupby statistics report.",
          "types": [
            "sf.report"
          ]
        }
      ]
    },
    {
      "domain": "stats",
      "name": "ss_pearsonr",
      "desc": "Calculate Pearson's product-moment correlation coefficient for vertical partitioning dataset\nby using secret sharing.\n- For large dataset(large than 10w samples & 200 features), recommend to use [Ring size: 128, Fxp: 40] options for SPU device.",
      "version": "0.0.1",
      "inputs": [
        {
          "name": "input_data",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "Specify which features to calculate correlation coefficient with. If empty, all features will be used"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "report",
          "desc": "Output Pearson's product-moment correlation coefficient report.",
          "types": [
            "sf.report"
          ]
        }
      ]
    },
    {
      "domain": "stats",
      "name": "ss_vif",
      "desc": "Calculate Variance Inflation Factor(VIF) for vertical partitioning dataset\nby using secret sharing.\n- For large dataset(large than 10w samples & 200 features), recommend to use [Ring size: 128, Fxp: 40] options for SPU device.",
      "version": "0.0.1",
      "inputs": [
        {
          "name": "input_data",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "Specify which features to calculate VIF with. If empty, all features will be used."
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "report",
          "desc": "Output Variance Inflation Factor(VIF) report.",
          "types": [
            "sf.report"
          ]
        }
      ]
    },
    {
      "domain": "stats",
      "name": "table_statistics",
      "desc": "Get a table of statistics,\nincluding each column's\n1. datatype\n2. total_count\n3. count\n4. count_na\n5. na_ratio\n6. min\n7. max\n8. mean\n9. var\n10. std\n11. sem\n12. skewness\n13. kurtosis\n14. q1\n15. q2\n16. q3\n17. moment_2\n18. moment_3\n19. moment_4\n20. central_moment_2\n21. central_moment_3\n22. central_moment_4\n23. sum\n24. sum_2\n25. sum_3\n26. sum_4\n- moment_2 means E[X^2].\n- central_moment_2 means E[(X - mean(X))^2].\n- sum_2 means sum(X^2).",
      "version": "0.0.1",
      "inputs": [
        {
          "name": "input_data",
          "desc": "Input table.",
          "types": [
            "sf.table.vertical_table",
            "sf.table.individual"
          ]
        }
      ],
      "outputs": [
        {
          "name": "report",
          "desc": "Output table statistics report.",
          "types": [
            "sf.report"
          ]
        }
      ]
    }
  ]
}