{
  "version": "1.0",
  "name": "secretflow",
  "desc": "First-party SecretFlow components.",
  "comps": [
    {
      "domain": "data_filter",
      "name": "condition_filter",
      "version": "1.0.0",
      "desc": "Filter the table based on a single column's values and condition.\nWarning: the party responsible for condition filtering will directly send the sample distribution to other participants.\nMalicious participants can obtain the distribution of characteristics by repeatedly calling with different filtering values.\nAudit the usage of this component carefully.",
      "attrs": [
        {
          "name": "comparator",
          "desc": "Comparator to use for comparison. Must be one of '==','<','<=','>','>=','IN','NOTNULL'",
          "type": "AT_STRING",
          "atomic": {
            "allowedValues": {
              "ss": [
                "==",
                "<",
                "<=",
                ">",
                ">=",
                "IN",
                "NOTNULL"
              ]
            }
          },
          "minorMax": -1
        },
        {
          "name": "bound_value",
          "desc": "Input a value for comparison; if the comparison condition is IN, you can input multiple values separated by ','; if the comparison condition is NOTNULL, the input is not needed.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        },
        {
          "name": "float_epsilon",
          "desc": "Epsilon value for floating point comparison. WARNING: due to floating point representation in computers, set this number slightly larger if you want filter out the values exactly at desired boundary. for example, abs(1.001 - 1.002) is slightly larger than 0.001, and therefore may not be filter out using == and epsilson = 0.001",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 1e-06
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "attrs": [
            {
              "name": "feature",
              "desc": "Feature to operate on.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "Output vertical table that satisfies the condition.",
          "types": [
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "output_ds_else",
          "desc": "Output vertical table that does not satisfies the condition.",
          "types": [
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "data_filter",
      "name": "expr_condition_filter",
      "version": "1.0.0",
      "desc": "Only row-level filtering is supported, column processing is not available;\nthe custom expression must comply with SQLite syntax standards",
      "attrs": [
        {
          "name": "expr",
          "desc": "The custom expression must comply with SQLite syntax standards",
          "type": "AT_STRING",
          "atomic": {},
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input vertical or individual table",
          "types": [
            "sf.table.individual",
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "Output table that satisfies the condition",
          "types": [
            "sf.table.individual",
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "output_ds_else",
          "desc": "Output table that does not satisfies the condition",
          "types": [
            "sf.table.individual",
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "data_filter",
      "name": "feature_filter",
      "version": "1.0.0",
      "desc": "Drop features from the dataset.",
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "attrs": [
            {
              "name": "drop_features",
              "desc": "Features to drop.",
              "colMinCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "Output vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "data_filter",
      "name": "sample",
      "version": "1.0.0",
      "desc": "Sample data set.",
      "attrs": [
        {
          "name": "sample_algorithm",
          "desc": "sample algorithm and parameters",
          "type": "AT_UNION_GROUP",
          "union": {
            "defaultSelection": "random"
          },
          "minorMax": -1
        },
        {
          "prefixes": [
            "sample_algorithm"
          ],
          "name": "random",
          "desc": "Random sample.",
          "type": "AT_STRUCT_GROUP",
          "minorMax": -1
        },
        {
          "prefixes": [
            "sample_algorithm",
            "random"
          ],
          "name": "frac",
          "desc": "Proportion of the dataset to sample in the set. The fraction should be larger than 0.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.8
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 10000.0
            }
          },
          "minorMax": -1
        },
        {
          "prefixes": [
            "sample_algorithm",
            "random"
          ],
          "name": "random_state",
          "desc": "Specify the random seed of the shuffling.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "1024"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          },
          "minorMax": -1
        },
        {
          "prefixes": [
            "sample_algorithm",
            "random"
          ],
          "name": "replacement",
          "desc": "If true, sampling with replacement. If false, sampling without replacement.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        },
        {
          "prefixes": [
            "sample_algorithm"
          ],
          "name": "system",
          "desc": "system sample.",
          "type": "AT_STRUCT_GROUP",
          "minorMax": -1
        },
        {
          "prefixes": [
            "sample_algorithm",
            "system"
          ],
          "name": "frac",
          "desc": "Proportion of the dataset to sample in the set. The fraction should be larger than 0 and less than or equal to 0.5.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.2
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 0.5
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "prefixes": [
            "sample_algorithm"
          ],
          "name": "stratify",
          "desc": "stratify sample.",
          "type": "AT_STRUCT_GROUP",
          "minorMax": -1
        },
        {
          "prefixes": [
            "sample_algorithm",
            "stratify"
          ],
          "name": "frac",
          "desc": "Proportion of the dataset to sample in the set. The fraction should be larger than 0.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.8
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 10000.0
            }
          },
          "minorMax": -1
        },
        {
          "prefixes": [
            "sample_algorithm",
            "stratify"
          ],
          "name": "random_state",
          "desc": "Specify the random seed of the shuffling.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "1024"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          },
          "minorMax": -1
        },
        {
          "prefixes": [
            "sample_algorithm",
            "stratify"
          ],
          "name": "observe_feature",
          "desc": "stratify sample observe feature.",
          "type": "AT_STRING",
          "atomic": {},
          "minorMax": -1
        },
        {
          "prefixes": [
            "sample_algorithm",
            "stratify"
          ],
          "name": "replacements",
          "desc": "If true, sampling with replacement. If false, sampling without replacement.",
          "type": "AT_BOOLS",
          "atomic": {
            "listMaxLengthInclusive": "-1"
          },
          "minorMax": -1
        },
        {
          "prefixes": [
            "sample_algorithm",
            "stratify"
          ],
          "name": "quantiles",
          "desc": "stratify sample quantiles",
          "type": "AT_FLOATS",
          "atomic": {
            "listMinLengthInclusive": "1",
            "listMaxLengthInclusive": "1000"
          },
          "minorMax": -1
        },
        {
          "prefixes": [
            "sample_algorithm",
            "stratify"
          ],
          "name": "weights",
          "desc": "stratify sample weights",
          "type": "AT_FLOATS",
          "atomic": {
            "listMaxLengthInclusive": "-1",
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            }
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical",
            "sf.table.individual"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "Output sampled dataset.",
          "types": [
            "sf.table.vertical",
            "sf.table.individual"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "report",
          "desc": "Output sample report",
          "types": [
            "sf.report"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "data_prep",
      "name": "psi",
      "version": "1.0.0",
      "desc": "PSI between two parties.",
      "attrs": [
        {
          "name": "protocol",
          "desc": "PSI protocol.",
          "type": "AT_UNION_GROUP",
          "union": {
            "defaultSelection": "PROTOCOL_RR22"
          },
          "minorMax": -1
        },
        {
          "prefixes": [
            "protocol"
          ],
          "name": "PROTOCOL_ECDH",
          "desc": "ECDH protocol.",
          "type": "AT_UNION_GROUP",
          "union": {
            "defaultSelection": "CURVE_25519"
          },
          "minorMax": -1
        },
        {
          "prefixes": [
            "protocol",
            "PROTOCOL_ECDH"
          ],
          "name": "CURVE_25519",
          "desc": "CURVE_25519",
          "minorMax": -1
        },
        {
          "prefixes": [
            "protocol",
            "PROTOCOL_ECDH"
          ],
          "name": "CURVE_FOURQ",
          "desc": "CURVE_FOURQ",
          "minorMax": -1
        },
        {
          "prefixes": [
            "protocol",
            "PROTOCOL_ECDH"
          ],
          "name": "CURVE_SM2",
          "desc": "CURVE_SM2",
          "minorMax": -1
        },
        {
          "prefixes": [
            "protocol",
            "PROTOCOL_ECDH"
          ],
          "name": "CURVE_SECP256K1",
          "desc": "CURVE_SECP256K1",
          "minorMax": -1
        },
        {
          "prefixes": [
            "protocol"
          ],
          "name": "PROTOCOL_RR22",
          "desc": "RR22 protocol.",
          "minorMax": -1
        },
        {
          "prefixes": [
            "protocol"
          ],
          "name": "PROTOCOL_KKRT",
          "desc": "KKRT protocol.",
          "minorMax": -1
        },
        {
          "name": "sort_result",
          "desc": "If false, output is not promised to be aligned. Warning: disable this option may lead to errors in the following components. DO NOT TURN OFF if you want to append other components.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          },
          "minorMax": -1
        },
        {
          "name": "receiver_parties",
          "desc": "Party names of receiver for result, all party will be receivers default; if only one party receive result, the result will be single-party table, hence you can not connect it to component with union table input.",
          "type": "AT_PARTY",
          "atomic": {
            "listMaxLengthInclusive": "2"
          },
          "minorMax": -1
        },
        {
          "name": "allow_empty_result",
          "desc": "Whether to allow the result to be empty, if allowed, an empty file will be saved, if not, an error will be reported.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        },
        {
          "name": "join_type",
          "desc": "join type, default is inner join.",
          "type": "AT_UNION_GROUP",
          "union": {
            "defaultSelection": "inner_join"
          },
          "minorMax": -1
        },
        {
          "prefixes": [
            "join_type"
          ],
          "name": "inner_join",
          "desc": "Inner join",
          "minorMax": -1
        },
        {
          "prefixes": [
            "join_type"
          ],
          "name": "left_join",
          "desc": "Left join",
          "type": "AT_STRUCT_GROUP",
          "minorMax": -1
        },
        {
          "prefixes": [
            "join_type",
            "left_join"
          ],
          "name": "left_side",
          "desc": "Required for left join",
          "type": "AT_PARTY",
          "atomic": {
            "listMinLengthInclusive": "1",
            "listMaxLengthInclusive": "1"
          },
          "minorMax": -1
        },
        {
          "prefixes": [
            "join_type"
          ],
          "name": "full_join",
          "desc": "Full join",
          "minorMax": -1
        },
        {
          "prefixes": [
            "join_type"
          ],
          "name": "difference",
          "desc": "Difference",
          "minorMax": -1
        },
        {
          "name": "input_ds1_keys_duplicated",
          "desc": "Whether key columns have duplicated rows, default is True.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          },
          "minorMax": -1
        },
        {
          "name": "input_ds2_keys_duplicated",
          "desc": "Whether key columns have duplicated rows, default is True.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds1",
          "desc": "Individual table for party 1",
          "types": [
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "keys",
              "desc": "Column(s) used to join.",
              "colMinCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "input_ds2",
          "desc": "Individual table for party 2",
          "types": [
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "keys",
              "desc": "Column(s) used to join.",
              "colMinCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "Output vertical table",
          "types": [
            "sf.table.vertical",
            "sf.table.individual"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "report",
          "desc": "Output psi report",
          "types": [
            "sf.report"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "data_prep",
      "name": "psi_tp",
      "version": "1.0.0",
      "desc": "PSI between three parties.",
      "attrs": [
        {
          "name": "ecdh_curve",
          "desc": "Curve type for ECDH PSI.",
          "type": "AT_UNION_GROUP",
          "union": {
            "defaultSelection": "CURVE_25519"
          },
          "minorMax": -1
        },
        {
          "prefixes": [
            "ecdh_curve"
          ],
          "name": "CURVE_25519",
          "desc": "CURVE_25519",
          "minorMax": -1
        },
        {
          "prefixes": [
            "ecdh_curve"
          ],
          "name": "CURVE_FOURQ",
          "desc": "CURVE_FOURQ",
          "minorMax": -1
        },
        {
          "prefixes": [
            "ecdh_curve"
          ],
          "name": "CURVE_SM2",
          "desc": "CURVE_SM2",
          "minorMax": -1
        },
        {
          "prefixes": [
            "ecdh_curve"
          ],
          "name": "CURVE_SECP256K1",
          "desc": "CURVE_SECP256K1",
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds1",
          "desc": "Individual table for party 1",
          "types": [
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "keys1",
              "desc": "Column(s) used to join.",
              "colMinCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "input_ds2",
          "desc": "Individual table for party 2",
          "types": [
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "keys2",
              "desc": "Column(s) used to join.",
              "colMinCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "input_ds3",
          "desc": "Individual table for party 3",
          "types": [
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "keys3",
              "desc": "Column(s) used to join.",
              "colMinCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "Output vertical table",
          "types": [
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "data_prep",
      "name": "train_test_split",
      "version": "1.0.0",
      "desc": "Split datasets into random train and test subsets.\n- Please check: https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html",
      "attrs": [
        {
          "name": "train_size",
          "desc": "Proportion of the dataset to include in the train subset. The sum of test_size and train_size should be in the (0, 1] range.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.75
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            }
          },
          "minorMax": -1
        },
        {
          "name": "test_size",
          "desc": "Proportion of the dataset to include in the test subset. The sum of test_size and train_size should be in the (0, 1] range.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.25
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            }
          },
          "minorMax": -1
        },
        {
          "name": "random_state",
          "desc": "Specify the random seed of the shuffling.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "1024"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          },
          "minorMax": -1
        },
        {
          "name": "shuffle",
          "desc": "Whether to shuffle the data before splitting.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "train_ds",
          "desc": "Output train dataset.",
          "types": [
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "test_ds",
          "desc": "Output test dataset.",
          "types": [
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "data_prep",
      "name": "unbalance_psi",
      "version": "1.0.0",
      "desc": "Unbalance psi with cache.",
      "attrs": [
        {
          "name": "join_type",
          "desc": "join type, default is inner join.",
          "type": "AT_UNION_GROUP",
          "union": {
            "defaultSelection": "inner_join"
          },
          "minorMax": -1
        },
        {
          "prefixes": [
            "join_type"
          ],
          "name": "inner_join",
          "desc": "Inner join",
          "minorMax": -1
        },
        {
          "prefixes": [
            "join_type"
          ],
          "name": "left_join",
          "desc": "Left join",
          "type": "AT_STRUCT_GROUP",
          "minorMax": -1
        },
        {
          "prefixes": [
            "join_type",
            "left_join"
          ],
          "name": "left_side",
          "desc": "Required for left join",
          "type": "AT_PARTY",
          "atomic": {
            "listMinLengthInclusive": "1",
            "listMaxLengthInclusive": "1"
          },
          "minorMax": -1
        },
        {
          "prefixes": [
            "join_type"
          ],
          "name": "full_join",
          "desc": "Full join",
          "minorMax": -1
        },
        {
          "prefixes": [
            "join_type"
          ],
          "name": "difference",
          "desc": "Difference",
          "minorMax": -1
        },
        {
          "name": "allow_empty_result",
          "desc": "Whether to allow the result to be empty, if allowed, an empty file will be saved, if not, an error will be reported.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        },
        {
          "name": "receiver_parties",
          "desc": "Party names of receiver for result, all party will be receivers default; if only one party receive result, the result will be single-party table, hence you can not connect it to component with union table input.",
          "type": "AT_PARTY",
          "atomic": {
            "listMaxLengthInclusive": "2"
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "client_ds",
          "desc": "Client dataset.",
          "types": [
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "keys",
              "desc": "Keys to be used for psi."
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "cache",
          "desc": "Server cache.",
          "types": [
            "sf.model.ub_psi.cache"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "Output table",
          "types": [
            "sf.table.individual",
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "data_prep",
      "name": "unbalance_psi_cache",
      "version": "1.0.0",
      "desc": "Generate cache for unbalance psi on both sides.",
      "attrs": [
        {
          "name": "client",
          "desc": "Party of client(party with the smaller dataset).",
          "type": "AT_PARTY",
          "atomic": {
            "listMinLengthInclusive": "1",
            "listMaxLengthInclusive": "1"
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "keys",
              "desc": "Keys to be used for psi.",
              "colMinCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_cache",
          "desc": "Output cache.",
          "types": [
            "sf.model.ub_psi.cache"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "data_prep",
      "name": "union",
      "version": "1.0.0",
      "desc": "Perform a horizontal merge of two data tables, supporting the individual table or vertical table on the same node.",
      "inputs": [
        {
          "name": "input_ds1",
          "desc": "The first input table",
          "types": [
            "sf.table.individual",
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "input_ds2",
          "desc": "The second input table",
          "types": [
            "sf.table.individual",
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "Output table",
          "types": [
            "sf.table.individual",
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "io",
      "name": "data_sink",
      "version": "1.0.0",
      "desc": "export data to an external data source",
      "attrs": [
        {
          "name": "output_party",
          "desc": "output party",
          "type": "AT_PARTY",
          "atomic": {
            "listMaxLengthInclusive": "1"
          },
          "minorMax": -1
        },
        {
          "name": "output_uri",
          "desc": "output uri, the uri format is datamesh:///{relative_path}?domaindata_id={domaindata_id}&datasource_id={datasource_id}&partition_spec={partition_spec}",
          "type": "AT_STRING",
          "atomic": {},
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_data",
          "desc": "Input dist data",
          "types": [
            "sf.table.individual",
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "io",
      "name": "data_source",
      "version": "1.0.0",
      "desc": "import data from an external data source",
      "attrs": [
        {
          "name": "party",
          "type": "AT_PARTY",
          "atomic": {
            "listMinLengthInclusive": "1",
            "listMaxLengthInclusive": "1"
          },
          "minorMax": -1
        },
        {
          "name": "uri",
          "desc": "input uri, the uri format is datamesh:///{relative_path}?domaindata_id={domaindata_id}&datasource_id={datasource_id}&partition_spec={partition_spec}",
          "type": "AT_STRING",
          "atomic": {},
          "minorMax": -1
        },
        {
          "name": "columns",
          "desc": "table column info, json format, for example {\"col1\": \"ID\", \"col2\":\"FEATURE\", \"col3\":\"LABEL\"}",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "output dataset",
          "types": [
            "sf.table.individual"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "io",
      "name": "identity",
      "version": "1.0.0",
      "desc": "map any input to output",
      "inputs": [
        {
          "name": "input_data",
          "desc": "Input data",
          "types": [
            "sf.model.ss_glm",
            "sf.model.sgb",
            "sf.model.ss_xgb",
            "sf.model.ss_sgd",
            "sf.rule.binning",
            "sf.read_data"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_data",
          "desc": "Output data",
          "types": [
            "sf.model.ss_glm",
            "sf.model.sgb",
            "sf.model.ss_xgb",
            "sf.model.ss_sgd",
            "sf.rule.binning",
            "sf.read_data"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "io",
      "name": "read_data",
      "version": "1.0.0",
      "desc": "read model or rules from sf cluster",
      "attrs": [
        {
          "name": "generalized_linear_model",
          "desc": "Whether to dump the complete generalized linear model. The complete generalized linear model contains link, y_scale, offset_col, and so on.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_data",
          "desc": "Input dist data",
          "types": [
            "sf.rule.binning",
            "sf.model.ss_glm",
            "sf.model.sgb"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_data",
          "desc": "Output rules or models in DistData.meta",
          "types": [
            "sf.read_data"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "io",
      "name": "write_data",
      "version": "1.0.0",
      "desc": "write model or rules back to sf cluster",
      "attrs": [
        {
          "name": "write_data",
          "desc": "rule or model protobuf by json format",
          "type": "AT_STRING",
          "atomic": {},
          "minorMax": -1
        },
        {
          "name": "write_data_type",
          "desc": "which rule or model is writing",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "sf.rule.binning"
            },
            "allowedValues": {
              "ss": [
                "sf.rule.binning",
                "sf.model.ss_glm",
                "sf.model.sgb"
              ]
            }
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_data",
          "desc": "Input dist data. Rule reconstructions may need hidden info in original rule for security considerations.",
          "types": [
            "sf.rule.binning",
            "sf.model.ss_glm",
            "sf.model.sgb",
            "sf.null"
          ],
          "isOptional": true,
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_data",
          "desc": "Output rules or models in sf cluster format",
          "types": [
            "sf.rule.binning",
            "sf.model.ss_glm",
            "sf.model.sgb"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "ml.eval",
      "name": "biclassification_eval",
      "version": "1.0.0",
      "desc": "Statistics evaluation for a bi-classification model on a dataset.\n1. summary_report: SummaryReport\n2. eq_frequent_bin_report: List[EqBinReport]\n3. eq_range_bin_report: List[EqBinReport]\n4. head_report: List[PrReport]\nreports for fpr = 0.001, 0.005, 0.01, 0.05, 0.1, 0.2",
      "attrs": [
        {
          "name": "bucket_size",
          "desc": "Number of buckets.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "min_item_cnt_per_bucket",
          "desc": "Min item cnt per bucket. If any bucket doesn't meet the requirement, error raises. For security reasons, we require this parameter to be at least 5.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "5"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "5"
            },
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input table with prediction and label, usually is a result from a prediction component.",
          "types": [
            "sf.table.vertical",
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "label",
              "desc": "The label name to use in the dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            },
            {
              "name": "prediction",
              "desc": "The prediction result column name to use in the dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "report",
          "desc": "Output report.",
          "types": [
            "sf.report"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "ml.eval",
      "name": "prediction_bias_eval",
      "version": "1.0.0",
      "desc": "Calculate prediction bias, ie. average of predictions - average of labels.",
      "attrs": [
        {
          "name": "bucket_num",
          "desc": "Num of bucket.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "min_item_cnt_per_bucket",
          "desc": "Min item cnt per bucket. If any bucket doesn't meet the requirement, error raises. For security reasons, we require this parameter to be at least 2.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "2"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "2"
            },
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "bucket_method",
          "desc": "Bucket method.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "equal_width"
            },
            "allowedValues": {
              "ss": [
                "equal_width",
                "equal_frequency"
              ]
            }
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input table with prediction and label, usually is a result from a prediction component.",
          "types": [
            "sf.table.vertical",
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "label",
              "desc": "The label name to use in the dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            },
            {
              "name": "prediction",
              "desc": "The prediction result column name to use in the dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "report",
          "desc": "Output report.",
          "types": [
            "sf.report"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "ml.eval",
      "name": "regression_eval",
      "version": "1.0.0",
      "desc": "Statistics evaluation for a regression model on a dataset.\nContained Statistics:\nR2 Score (r2_score): It is a statistical measure that represents the proportion of the variance in the dependent variable that can be predicted from the independent variables. It ranges from -inf to 1, where a higher value indicates a better fit. (the value can be negative because the\nmodel can be arbitrarily worse). In the general case when the true y is non-constant, a constant model that always predicts the average y\ndisregarding the input features would get a :math:'R^2' score of 0.0.\nMean Absolute Error (mean_abs_err): It calculates the average absolute difference between the predicted and actual values. It provides a measure of the average magnitude of the errors.\nMean Absolute Percentage Error (mean_abs_percent_err): It calculates the average absolute percentage difference between the predicted and actual values. It measures the average magnitude of the errors in terms of percentages.\nSum of Squared Errors (sum_squared_errors): It calculates the sum of the squared differences between the predicted and actual values. It provides an overall measure of the model's performance.\nMean Squared Error (mean_squared_errors): It calculates the average of the squared differences between the predicted and actual values. It is widely used as a loss function in regression problems.\nRoot Mean Squared Error (root_mean_squared_errors): It is the square root of the mean squared error. It provides a measure of the average magnitude of the errors in the original scale of the target variable.\nMean of True Values (y_true_mean): It calculates the average of the actual values in the target variable. It can be useful for establishing a baseline for the model's performance.\nMean of Predicted Values (y_pred_mean): It calculates the average of the predicted values. It can be compared with the y_true_mean to get an idea of the model's bias.\nResidual Histograms (residual_hists): It represents the distribution of the differences between the predicted and actual values. It helps to understand the spread and pattern of the errors.",
      "attrs": [
        {
          "name": "bucket_size",
          "desc": "Number of buckets for residual histogram.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "10000"
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input table with prediction and label, usually is a result from a prediction component.",
          "types": [
            "sf.table.vertical",
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "label",
              "desc": "The label name to use in the dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            },
            {
              "name": "prediction",
              "desc": "The prediction result column name to use in the dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "report",
          "desc": "Output report.",
          "types": [
            "sf.report"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "ml.eval",
      "name": "ss_pvalue",
      "version": "1.0.0",
      "desc": "Calculate P-Value for LR model training on vertical partitioning dataset by using secret sharing.\nFor large dataset(large than 10w samples & 200 features),\nrecommend to use [Ring size: 128, Fxp: 40] options for SPU device.",
      "inputs": [
        {
          "name": "input_model",
          "desc": "Input model.",
          "types": [
            "sf.model.ss_sgd",
            "sf.model.ss_glm"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "report",
          "desc": "Output P-Value report.",
          "types": [
            "sf.report"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "ml.predict",
      "name": "gnb_predict",
      "version": "1.0.0",
      "desc": "Predict using the gaussian naive bayes model. This component is currently experimental.",
      "labels": {
        "package": "sml",
        "experimental": "true"
      },
      "attrs": [
        {
          "name": "receiver",
          "desc": "Party of receiver.",
          "type": "AT_PARTY",
          "atomic": {
            "listMinLengthInclusive": "1",
            "listMaxLengthInclusive": "1"
          },
          "minorMax": -1
        },
        {
          "name": "pred_name",
          "desc": "Column name for predictions.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "pred"
            }
          },
          "minorMax": -1
        },
        {
          "name": "save_ids",
          "desc": "Whether to save ids columns into output prediction table. If true, input feature_dataset must contain id columns, and receiver party must be id owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        },
        {
          "name": "save_label",
          "desc": "Whether or not to save real label columns into output pred file. If true, input feature_dataset must contain label columns and receiver party must be label owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_model",
          "desc": "model",
          "types": [
            "sf.model.gnb"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "attrs": [
            {
              "name": "saved_features",
              "desc": "which features should be saved with prediction result"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "Output prediction.",
          "types": [
            "sf.table.individual"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "ml.predict",
      "name": "gpc_predict",
      "version": "1.0.0",
      "desc": "Predict using the gaussian process classifier model. This component is currently experimental.",
      "labels": {
        "package": "sml",
        "experimental": "true"
      },
      "attrs": [
        {
          "name": "receiver",
          "desc": "Party of receiver.",
          "type": "AT_PARTY",
          "atomic": {
            "listMinLengthInclusive": "1",
            "listMaxLengthInclusive": "1"
          },
          "minorMax": -1
        },
        {
          "name": "pred_name",
          "desc": "Column name for predictions.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "pred"
            }
          },
          "minorMax": -1
        },
        {
          "name": "save_ids",
          "desc": "Whether to save ids columns into output prediction table. If true, input feature_dataset must contain id columns, and receiver party must be id owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        },
        {
          "name": "save_label",
          "desc": "Whether or not to save real label columns into output pred file. If true, input feature_dataset must contain label columns and receiver party must be label owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_model",
          "desc": "model",
          "types": [
            "sf.model.gpc"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "attrs": [
            {
              "name": "saved_features",
              "desc": "which features should be saved with prediction result"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "Output prediction.",
          "types": [
            "sf.table.individual"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "ml.predict",
      "name": "kmeans_predict",
      "version": "1.0.0",
      "desc": "Predict using the KMeans model. This component is currently experimental.",
      "labels": {
        "package": "sml",
        "experimental": "true"
      },
      "attrs": [
        {
          "name": "receiver",
          "desc": "Party of receiver.",
          "type": "AT_PARTY",
          "atomic": {
            "listMinLengthInclusive": "1",
            "listMaxLengthInclusive": "1"
          },
          "minorMax": -1
        },
        {
          "name": "pred_name",
          "desc": "Column name for predictions.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "pred"
            }
          },
          "minorMax": -1
        },
        {
          "name": "save_ids",
          "desc": "Whether to save ids columns into output prediction table. If true, input feature_dataset must contain id columns, and receiver party must be id owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_model",
          "desc": "model",
          "types": [
            "sf.model.kmeans"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "attrs": [
            {
              "name": "saved_features",
              "desc": "which features should be saved with prediction result"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "Output prediction.",
          "types": [
            "sf.table.individual"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "ml.predict",
      "name": "knn_predict",
      "version": "1.0.0",
      "desc": "Predict using the K neighbors classifier model. This component is currently experimental.",
      "labels": {
        "package": "sml",
        "experimental": "true"
      },
      "attrs": [
        {
          "name": "receiver",
          "desc": "Party of receiver.",
          "type": "AT_PARTY",
          "atomic": {
            "listMinLengthInclusive": "1",
            "listMaxLengthInclusive": "1"
          },
          "minorMax": -1
        },
        {
          "name": "pred_name",
          "desc": "Column name for predictions.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "pred"
            }
          },
          "minorMax": -1
        },
        {
          "name": "save_ids",
          "desc": "Whether to save ids columns into output prediction table. If true, input feature_dataset must contain id columns, and receiver party must be id owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        },
        {
          "name": "save_label",
          "desc": "Whether or not to save real label columns into output pred file. If true, input feature_dataset must contain label columns and receiver party must be label owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_model",
          "desc": "model",
          "types": [
            "sf.model.knn"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "attrs": [
            {
              "name": "saved_features",
              "desc": "which features should be saved with prediction result"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "Output prediction.",
          "types": [
            "sf.table.individual"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "ml.predict",
      "name": "serving_model_inferencer",
      "version": "1.1.0",
      "desc": "batch predicting online service models in offline",
      "attrs": [
        {
          "name": "receiver",
          "desc": "Party of receiver.",
          "type": "AT_PARTY",
          "atomic": {
            "listMinLengthInclusive": "1",
            "listMaxLengthInclusive": "1"
          },
          "minorMax": -1
        },
        {
          "name": "pred_name",
          "desc": "Column name for predictions.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "score"
            }
          },
          "minorMax": -1
        },
        {
          "name": "input_block_size",
          "desc": "block size (Byte) for input data streaming",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "65536"
            }
          },
          "minorMin": 1,
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "serving_model",
          "desc": "Input serving model.",
          "types": [
            "sf.serving.model"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "input_ds",
          "desc": "Input vertical table or individual table.",
          "types": [
            "sf.table.vertical",
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "saved_columns",
              "desc": "which columns should be saved with prediction result"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "Output prediction.",
          "types": [
            "sf.table.individual"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "ml.predict",
      "name": "sgb_predict",
      "version": "1.0.0",
      "desc": "Predict using SGB model.",
      "attrs": [
        {
          "name": "receiver",
          "desc": "Party of receiver.",
          "type": "AT_PARTY",
          "atomic": {
            "listMinLengthInclusive": "1",
            "listMaxLengthInclusive": "1"
          },
          "minorMax": -1
        },
        {
          "name": "pred_name",
          "desc": "Name for prediction column",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "pred"
            }
          },
          "minorMax": -1
        },
        {
          "name": "save_ids",
          "desc": "Whether to save ids columns into output prediction table. If true, input feature_dataset must contain id columns, and receiver party must be id owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        },
        {
          "name": "save_label",
          "desc": "Whether or not to save real label columns into output pred file. If true, input feature_dataset must contain label columns and receiver party must be label owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_model",
          "desc": "model",
          "types": [
            "sf.model.sgb"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "attrs": [
            {
              "name": "saved_features",
              "desc": "which features should be saved with prediction result"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "Output prediction.",
          "types": [
            "sf.table.individual"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "ml.predict",
      "name": "slnn_predict",
      "version": "0.0.2",
      "desc": "Predict using the SLNN model.\nThis component is not enabled by default, it requires the use of the full version\nof secretflow image and setting the ENABLE_NN environment variable to true.",
      "attrs": [
        {
          "name": "batch_size",
          "desc": "The number of examples per batch.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "8192"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          },
          "minorMax": -1
        },
        {
          "name": "receiver",
          "desc": "Party of receiver.",
          "type": "AT_PARTY",
          "atomic": {
            "listMinLengthInclusive": "1",
            "listMaxLengthInclusive": "1"
          },
          "minorMax": -1
        },
        {
          "name": "pred_name",
          "desc": "Column name for predictions.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "pred"
            }
          },
          "minorMax": -1
        },
        {
          "name": "save_ids",
          "desc": "Whether to save ids columns into output prediction table. If true, input feature_dataset must contain id columns, and receiver party must be id owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        },
        {
          "name": "save_label",
          "desc": "Whether or not to save real label columns into output pred file. If true, input feature_dataset must contain label columns and receiver party must be label owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "model",
          "desc": "Input model.",
          "types": [
            "sf.model.sl_nn"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "feature_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "attrs": [
            {
              "name": "saved_features",
              "desc": "which features should be saved with prediction result"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "pred",
          "desc": "Output prediction.",
          "types": [
            "sf.table.individual"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "ml.predict",
      "name": "ss_glm_predict",
      "version": "1.1.0",
      "desc": "Predict using the SSGLM model.",
      "attrs": [
        {
          "name": "receiver",
          "desc": "Party of receiver.",
          "type": "AT_PARTY",
          "atomic": {
            "listMinLengthInclusive": "1",
            "listMaxLengthInclusive": "1"
          },
          "minorMax": -1
        },
        {
          "name": "pred_name",
          "desc": "Column name for predictions.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "pred"
            }
          },
          "minorMax": -1
        },
        {
          "name": "save_ids",
          "desc": "Whether to save ids columns into output prediction table. If true, input feature_dataset must contain id columns, and receiver party must be id owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          },
          "minorMax": -1
        },
        {
          "name": "save_label",
          "desc": "Whether or not to save real label columns into output pred file. If true, input feature_dataset must contain label columns and receiver party must be label owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_model",
          "desc": "Input model.",
          "types": [
            "sf.model.ss_glm"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "attrs": [
            {
              "name": "saved_features",
              "desc": "which features should be saved with prediction result"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "Output prediction.",
          "types": [
            "sf.table.individual"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "ml.predict",
      "name": "ss_sgd_predict",
      "version": "1.0.0",
      "desc": "Predict using the SS-SGD model.",
      "attrs": [
        {
          "name": "batch_size",
          "desc": "The number of training examples utilized in one iteration.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "1024"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          },
          "minorMax": -1
        },
        {
          "name": "receiver",
          "desc": "Party of receiver.",
          "type": "AT_PARTY",
          "atomic": {
            "listMinLengthInclusive": "1",
            "listMaxLengthInclusive": "1"
          },
          "minorMax": -1
        },
        {
          "name": "pred_name",
          "desc": "Column name for predictions.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "pred"
            }
          },
          "minorMax": -1
        },
        {
          "name": "save_ids",
          "desc": "Whether to save ids columns into output prediction table. If true, input feature_dataset must contain id columns, and receiver party must be id owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          },
          "minorMax": -1
        },
        {
          "name": "save_label",
          "desc": "Whether or not to save real label columns into output pred file. If true, input feature_dataset must contain label columns and receiver party must be label owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_model",
          "desc": "Input model.",
          "types": [
            "sf.model.ss_sgd"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "attrs": [
            {
              "name": "saved_features",
              "desc": "which features should be saved with prediction result"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "Output prediction.",
          "types": [
            "sf.table.individual"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "ml.predict",
      "name": "ss_xgb_predict",
      "version": "1.0.0",
      "desc": "Predict using the SS-XGB model.",
      "attrs": [
        {
          "name": "receiver",
          "desc": "Party of receiver.",
          "type": "AT_PARTY",
          "atomic": {
            "listMinLengthInclusive": "1",
            "listMaxLengthInclusive": "1"
          },
          "minorMax": -1
        },
        {
          "name": "pred_name",
          "desc": "Column name for predictions.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "pred"
            }
          },
          "minorMax": -1
        },
        {
          "name": "save_ids",
          "desc": "Whether to save ids columns into output prediction table. If true, input feature_dataset must contain id columns, and receiver party must be id owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        },
        {
          "name": "save_label",
          "desc": "Whether or not to save real label columns into output pred file. If true, input feature_dataset must contain label columns and receiver party must be label owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_model",
          "desc": "model",
          "types": [
            "sf.model.ss_xgb"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "attrs": [
            {
              "name": "saved_features",
              "desc": "which features should be saved with prediction result"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "Output prediction.",
          "types": [
            "sf.table.individual"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "ml.train",
      "name": "gnb_train",
      "version": "1.0.0",
      "desc": "Provide gaussian naive bayes training. This component is currently experimental.",
      "labels": {
        "package": "sml",
        "experimental": "true"
      },
      "attrs": [
        {
          "name": "var_smoothing",
          "desc": "Portion of the largest variance of all features that is added to variances for calculation stability.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 1e-06
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          },
          "minorMax": -1
        },
        {
          "name": "n_classes",
          "desc": "The number of classes in the training data, must be preprocessed to 0, 1, 2, ..., n_classes - 1",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "2"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "2"
            },
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "which features should be used for training.",
              "colMinCntInclusive": "1"
            },
            {
              "name": "label",
              "desc": "Label of train dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_model",
          "desc": "Output model.",
          "types": [
            "sf.model.gnb"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "ml.train",
      "name": "gpc_train",
      "version": "1.0.0",
      "desc": "Provide gaussian process classifier training. This component is currently experimental.",
      "labels": {
        "package": "sml",
        "experimental": "true"
      },
      "attrs": [
        {
          "name": "max_iter_predict",
          "desc": "The maximum number of iterations in Newton's method for approximating the posterior during predict. Smaller values will reduce computation time at the cost of worse results.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "20"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "n_classes",
          "desc": "The number of classes in the training data, must be preprocessed to 0, 1, 2, ...",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "2"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical",
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "which features should be used for training.",
              "colMinCntInclusive": "1"
            },
            {
              "name": "label",
              "desc": "Label of train dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_model",
          "desc": "Output model.",
          "types": [
            "sf.model.gpc"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "ml.train",
      "name": "kmeans_train",
      "version": "1.0.0",
      "desc": "Provide kmeans training. This component is currently experimental.",
      "labels": {
        "package": "sml",
        "experimental": "true"
      },
      "attrs": [
        {
          "name": "n_clusters",
          "desc": "Number of clusters.",
          "type": "AT_INT",
          "atomic": {
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "max_iter",
          "desc": "Number of iterations for kmeans training.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "n_init",
          "desc": "Number of groups for initial centers.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "1"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "init_method",
          "desc": "Params initialization method.",
          "type": "AT_UNION_GROUP",
          "union": {
            "defaultSelection": "kmeans_plus_plus"
          },
          "minorMax": -1
        },
        {
          "prefixes": [
            "init_method"
          ],
          "name": "random",
          "desc": "random method",
          "minorMax": -1
        },
        {
          "prefixes": [
            "init_method"
          ],
          "name": "kmeans_plus_plus",
          "desc": "k-means++ method",
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "which features should be used for training.",
              "colMinCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_model",
          "desc": "Output model.",
          "types": [
            "sf.model.kmeans"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "ml.train",
      "name": "knn_train",
      "version": "1.0.0",
      "desc": "Provide k neighbors classifier training. This component is currently experimental.",
      "labels": {
        "package": "sml",
        "experimental": "true"
      },
      "attrs": [
        {
          "name": "weights",
          "desc": "weights function used in prediction method.",
          "type": "AT_UNION_GROUP",
          "union": {
            "defaultSelection": "uniform"
          },
          "minorMax": -1
        },
        {
          "prefixes": [
            "weights"
          ],
          "name": "uniform",
          "desc": "Uniform weights. All points in each neighborhood are weighted equally.",
          "minorMax": -1
        },
        {
          "prefixes": [
            "weights"
          ],
          "name": "distance",
          "desc": "Weight points by the inverse of their distance.",
          "minorMax": -1
        },
        {
          "name": "n_classes",
          "desc": "The number of classes in the training data, must be preprocessed to 0, 1, 2, ...",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "2"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "n_neighbors",
          "desc": "Number of neighbors to use for prediction.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "5"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "which features should be used for training.",
              "colMinCntInclusive": "1"
            },
            {
              "name": "label",
              "desc": "Label of train dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_model",
          "desc": "Output model.",
          "types": [
            "sf.model.knn"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "ml.train",
      "name": "sgb_train",
      "version": "1.1.0",
      "desc": "Provides both classification and regression tree boosting (also known as GBDT, GBM)\nfor vertical split dataset setting by using secure boost.\n- SGB is short for SecureBoost. Compared to its safer counterpart SS-XGB, SecureBoost focused on protecting label holder.\n- Check https://arxiv.org/abs/1901.08755.",
      "attrs": [
        {
          "name": "num_boost_round",
          "desc": "Number of boosting iterations.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "max_depth",
          "desc": "Maximum depth of a tree.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "5"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "16"
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "learning_rate",
          "desc": "Step size shrinkage used in update to prevent overfitting.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "objective",
          "desc": "Specify the learning objective.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "logistic"
            },
            "allowedValues": {
              "ss": [
                "linear",
                "logistic",
                "tweedie"
              ]
            }
          },
          "minorMax": -1
        },
        {
          "name": "reg_lambda",
          "desc": "L2 regularization term on weights.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 10000.0
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "gamma",
          "desc": "Greater than 0 means pre-pruning enabled. If gain of a node is less than this value, it would be pruned.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 1.0
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 10000.0
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "colsample_by_tree",
          "desc": "Subsample ratio of columns when constructing each tree.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 1.0
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "sketch_eps",
          "desc": "This roughly translates into O(1 / sketch_eps) number of bins.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "base_score",
          "desc": "The initial prediction score of all instances, global bias.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {
              "f": -10.0
            },
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 10.0
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "seed",
          "desc": "Pseudorandom number generator seed.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "42"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "fixed_point_parameter",
          "desc": "Any floating point number encoded by heu, will multiply a scale and take the round, scale = 2 ** fixed_point_parameter. larger value may mean more numerical accuracy, but too large will lead to overflow problem.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "20"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "100"
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "first_tree_with_label_holder_feature",
          "desc": "Whether to train the first tree with label holder's own features.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        },
        {
          "name": "batch_encoding_enabled",
          "desc": "If use batch encoding optimization.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          },
          "minorMax": -1
        },
        {
          "name": "enable_quantization",
          "desc": "Whether enable quantization of g and h.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        },
        {
          "name": "quantization_scale",
          "desc": "Scale the sum of g to the specified value.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 10000.0
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 10000000.0
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "max_leaf",
          "desc": "Maximum leaf of a tree. Only effective if train leaf wise.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "15"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "32768"
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "rowsample_by_tree",
          "desc": "Row sub sample ratio of the training instances.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 1.0
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "enable_goss",
          "desc": "Whether to enable GOSS.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        },
        {
          "name": "top_rate",
          "desc": "GOSS-specific parameter. The fraction of large gradients to sample.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.3
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "bottom_rate",
          "desc": "GOSS-specific parameter. The fraction of small gradients to sample.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.5
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "tree_growing_method",
          "desc": "How to grow tree?",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "level"
            }
          },
          "minorMax": -1
        },
        {
          "name": "enable_early_stop",
          "desc": "Whether to enable early stop during training.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        },
        {
          "name": "enable_monitor",
          "desc": "Whether to enable monitoring performance during training.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        },
        {
          "name": "eval_metric",
          "desc": "Use what metric for monitoring and early stop? Currently support ['roc_auc', 'rmse', 'mse', 'tweedie_deviance', 'tweedie_nll']",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "roc_auc"
            },
            "allowedValues": {
              "ss": [
                "roc_auc",
                "rmse",
                "mse",
                "tweedie_deviance",
                "tweedie_nll"
              ]
            }
          },
          "minorMax": -1
        },
        {
          "name": "validation_fraction",
          "desc": "Early stop specific parameter. Only effective if early stop enabled. The fraction of samples to use as validation set.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            }
          },
          "minorMax": -1
        },
        {
          "name": "stopping_rounds",
          "desc": "Early stop specific parameter. If more than 'stopping_rounds' consecutive rounds without improvement, training will stop. Only effective if early stop enabled",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "1"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "1024"
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "stopping_tolerance",
          "desc": "Early stop specific parameter. If metric on validation set is no longer improving by at least this amount, then consider not improving.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "tweedie_variance_power",
          "desc": "Parameter that controls the variance of the Tweedie distribution.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 1.5
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "f": 1.0
            },
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 2.0
            }
          },
          "minorMax": -1
        },
        {
          "name": "save_best_model",
          "desc": "Whether to save the best model on validation set during training.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        },
        {
          "name": "report_importances",
          "desc": "Whether to report feature importances. Currently supported importances are: {\"gain\": \"the average gain across all splits the feature is used in.\", \"weight\": \"the number of times a feature is used to split the data across all trees.\"}",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMin": 1,
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "which features should be used for training.",
              "colMinCntInclusive": "1"
            },
            {
              "name": "label",
              "desc": "Label of train dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_model",
          "desc": "Output model.",
          "types": [
            "sf.model.sgb"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "report",
          "desc": "If report_importances is true, report feature importances",
          "types": [
            "sf.report"
          ],
          "variableMax": -1,
          "minorMin": 1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "ml.train",
      "name": "slnn_train",
      "version": "0.0.1",
      "desc": "Train nn models for vertical partitioning dataset by split learning.\nThis component is not enabled by default, it requires the use of the full version\nof secretflow image and setting the ENABLE_NN environment variable to true.\nSince it is necessary to define the model structure using python code,\nalthough the range of syntax and APIs that can be used has been restricted,\nthere are still potential security risks. It is recommended to use it in\nconjunction with process sandboxes such as nsjail.",
      "attrs": [
        {
          "name": "models",
          "desc": "Define the models for training.",
          "type": "AT_STRING",
          "atomic": {
            "defaultValue": {
              "s": "# pre imported:\n# import tensorflow as tf\n# from tensorflow import Module, keras\n# from tensorflow.keras import Model, layers\n# from tensorflow.keras.layers import Layer\n# from secretflow_fl.ml.nn import applications as apps\n\ndef create_base_model(input_dim, output_dim):\n    model = keras.Sequential(\n        [\n            keras.Input(shape=input_dim),\n            layers.Dense(100, activation=\"relu\"),\n            layers.Dense(output_dim, activation=\"relu\"),\n        ]\n    )\n    return model\n\ndef create_fuse_model(input_dim):\n    input_layers = [keras.Input(input_dim), keras.Input(input_dim)]\n    merged_layer = layers.concatenate(input_layers)\n    fuse_layer = layers.Dense(64, activation='relu')(merged_layer)\n    output = layers.Dense(1, activation='sigmoid')(fuse_layer)\n    return keras.Model(inputs=input_layers, outputs=output)\n\nhidden_size = 64\n\nfit(\n    client_base=create_base_model(12, hidden_size),\n    server_base=create_base_model(4, hidden_size),\n    server_fuse=create_fuse_model(hidden_size),\n)\n"
            }
          },
          "minorMax": -1
        },
        {
          "name": "epochs",
          "desc": "The number of complete pass through the training data.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "learning_rate",
          "desc": "The step size at each iteration in one iteration.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.001
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          },
          "minorMax": -1
        },
        {
          "name": "batch_size",
          "desc": "The number of training examples utilized in one iteration.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "512"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          },
          "minorMax": -1
        },
        {
          "name": "validattion_prop",
          "desc": "The proportion of validation set to total data set.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            }
          },
          "minorMax": -1
        },
        {
          "name": "loss",
          "desc": "Loss function.",
          "type": "AT_UNION_GROUP",
          "union": {
            "defaultSelection": "builtin"
          },
          "minorMax": -1
        },
        {
          "prefixes": [
            "loss"
          ],
          "name": "builtin",
          "desc": "Builtin loss function.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "mean_squared_error"
            },
            "allowedValues": {
              "ss": [
                "binary_crossentropy",
                "categorical_crossentropy",
                "mean_squared_error",
                "mean_squared_logarithmic_error",
                "mean_absolute_error",
                "mean_absolute_percentage_error",
                "cosine_similarity",
                "huber",
                "kl_divergence",
                "log_cosh",
                "poisson",
                "binary_focal_crossentropy",
                "sparse_categorical_crossentropy",
                "hinge",
                "categorical_hinge",
                "squared_hinge"
              ]
            }
          },
          "minorMax": -1
        },
        {
          "prefixes": [
            "loss"
          ],
          "name": "custom",
          "desc": "Custom loss function.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "def loss(y_true, y_pred):\n    return tf.keras.losses.mean_squared_error(y_true, y_pred)\n\n\ncompile_loss(loss)\n\n"
            }
          },
          "minorMax": -1
        },
        {
          "name": "optimizer",
          "desc": "Optimizer.",
          "type": "AT_STRUCT_GROUP",
          "minorMax": -1
        },
        {
          "prefixes": [
            "optimizer"
          ],
          "name": "name",
          "desc": "Optimizer name.",
          "type": "AT_STRING",
          "atomic": {
            "defaultValue": {
              "s": "Adam"
            },
            "allowedValues": {
              "ss": [
                "Adam",
                "SGD",
                "RMSprop",
                "AdamW",
                "Adamax",
                "Nadam",
                "Adagrad",
                "Adadelta",
                "Adafactor",
                "Ftrl",
                "Lion"
              ]
            }
          },
          "minorMax": -1
        },
        {
          "prefixes": [
            "optimizer"
          ],
          "name": "params",
          "desc": "Additional optimizer parameters in JSON format.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        },
        {
          "name": "metrics",
          "desc": "Metrics.",
          "type": "AT_STRINGS",
          "atomic": {
            "listMaxLengthInclusive": "10",
            "isOptional": true,
            "defaultValue": {
              "ss": [
                "AUC"
              ]
            },
            "allowedValues": {
              "ss": [
                "AUC",
                "Accuracy",
                "Precision",
                "Recall",
                "BinaryAccuracy",
                "BinaryCrossentropy",
                "CategoricalAccuracy",
                "CategoricalCrossentropy",
                "CosineSimilarity",
                "FalseNegatives",
                "FalsePositives",
                "TrueNegatives",
                "TruePositives",
                "KLDivergence",
                "LogCoshError",
                "MeanAbsoluteError",
                "MeanAbsolutePercentageError",
                "MeanRelativeError",
                "MeanSquaredError",
                "MeanSquaredLogarithmicError",
                "Hinge",
                "SquaredHinge",
                "CategoricalHinge",
                "BinaryIoU",
                "IoU",
                "MeanIoU",
                "OneHotIoU",
                "OneHotMeanIoU",
                "Poisson",
                "PrecisionAtRecall",
                "RecallAtPrecision",
                "RootMeanSquaredError",
                "SensitivityAtSpecificity",
                "SparseCategoricalAccuracy",
                "SparseCategoricalCrossentropy",
                "SparseTopKCategoricalAccuracy",
                "SpecificityAtSensitivity",
                "TopKCategoricalAccuracy"
              ]
            }
          },
          "minorMax": -1
        },
        {
          "name": "model_input_scheme",
          "desc": "Input scheme of base model, tensor: merge all features into one tensor; tensor_dict: each feature as a tensor.",
          "type": "AT_STRING",
          "atomic": {
            "defaultValue": {
              "s": "tensor"
            },
            "allowedValues": {
              "ss": [
                "tensor",
                "tensor_dict"
              ]
            }
          },
          "minorMax": -1
        },
        {
          "name": "strategy",
          "desc": "Split learning strategy.",
          "type": "AT_STRUCT_GROUP",
          "minorMax": -1
        },
        {
          "prefixes": [
            "strategy"
          ],
          "name": "name",
          "desc": "Split learning strategy name.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "pipeline"
            },
            "allowedValues": {
              "ss": [
                "pipeline",
                "split_nn",
                "split_async",
                "split_state_async"
              ]
            }
          },
          "minorMax": -1
        },
        {
          "prefixes": [
            "strategy"
          ],
          "name": "params",
          "desc": "Additional strategy parameters in JSON format.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "{\"pipeline_size\":2}"
            }
          },
          "minorMax": -1
        },
        {
          "name": "compressor",
          "desc": "Compressor for hiddens and gradients.",
          "type": "AT_STRUCT_GROUP",
          "minorMax": -1
        },
        {
          "prefixes": [
            "compressor"
          ],
          "name": "name",
          "desc": "Compressor name.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "allowedValues": {
              "ss": [
                "",
                "topk_sparse",
                "random_sparse",
                "stc_sparse",
                "scr_sparse",
                "quantized_fp",
                "quantized_lstm",
                "quantized_kmeans",
                "quantized_zeropoint",
                "mixed_compressor"
              ]
            }
          },
          "minorMax": -1
        },
        {
          "prefixes": [
            "compressor"
          ],
          "name": "params",
          "desc": "Additional compressor parameters in JSON format.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "train_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "which features should be used for training.",
              "colMinCntInclusive": "1"
            },
            {
              "name": "label",
              "desc": "Label of train dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_model",
          "desc": "Output model.",
          "types": [
            "sf.model.sl_nn"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "reports",
          "desc": "Output report.",
          "types": [
            "sf.report"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "ml.train",
      "name": "ss_glm_train",
      "version": "1.1.0",
      "desc": "generalized linear model (GLM) is a flexible generalization of ordinary linear regression.\nThe GLM generalizes linear regression by allowing the linear model to be related to the response\nvariable via a link function and by allowing the magnitude of the variance of each measurement to\nbe a function of its predicted value.",
      "attrs": [
        {
          "name": "epochs",
          "desc": "The number of complete pass through the training data.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "learning_rate",
          "desc": "The step size at each iteration in one iteration.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          },
          "minorMax": -1
        },
        {
          "name": "batch_size",
          "desc": "The number of training examples utilized in one iteration.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "1024"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          },
          "minorMax": -1
        },
        {
          "name": "link_type",
          "desc": "link function type",
          "type": "AT_STRING",
          "atomic": {
            "allowedValues": {
              "ss": [
                "Logit",
                "Log",
                "Reciprocal",
                "Identity"
              ]
            }
          },
          "minorMax": -1
        },
        {
          "name": "label_dist_type",
          "desc": "label distribution type",
          "type": "AT_STRING",
          "atomic": {
            "allowedValues": {
              "ss": [
                "Bernoulli",
                "Poisson",
                "Gamma",
                "Tweedie"
              ]
            }
          },
          "minorMax": -1
        },
        {
          "name": "tweedie_power",
          "desc": "Tweedie distribution power parameter",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 1.0
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 2.0
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "dist_scale",
          "desc": "A guess value for distribution's scale",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 1.0
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "f": 1.0
            },
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "iter_start_irls",
          "desc": "run a few rounds of IRLS training as the initialization of w, 0 disable",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "decay_epoch",
          "desc": "decay learning interval",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "decay_rate",
          "desc": "decay learning rate",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            }
          },
          "minorMax": -1
        },
        {
          "name": "optimizer",
          "desc": "which optimizer to use: IRLS(Iteratively Reweighted Least Squares) or SGD(Stochastic Gradient Descent)",
          "type": "AT_STRING",
          "atomic": {
            "allowedValues": {
              "ss": [
                "SGD",
                "IRLS"
              ]
            }
          },
          "minorMax": -1
        },
        {
          "name": "l2_lambda",
          "desc": "L2 regularization term",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "infeed_batch_size_limit",
          "desc": "size of a single block, default to 8w * 100. increase the size will increase memory cost, but may decrease running time. Suggested to be as large as possible. (too large leads to OOM)",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "8000000"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1000"
            },
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "8000000"
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "fraction_of_validation_set",
          "desc": "fraction of training set to be used as the validation set. ineffective for 'weight' stopping_metric",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.2
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            }
          },
          "minorMax": -1
        },
        {
          "name": "random_state",
          "desc": "random state for validation split",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "1212"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "stopping_metric",
          "desc": "use what metric as the condition for early stop? Must be one of ['deviance', 'MSE', 'RMSE', 'AUC', 'weight']. only logit link supports AUC metric (note that AUC is very, very expensive in MPC)",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "deviance"
            },
            "allowedValues": {
              "ss": [
                "deviance",
                "MSE",
                "RMSE",
                "AUC",
                "weight"
              ]
            }
          },
          "minorMax": -1
        },
        {
          "name": "stopping_rounds",
          "desc": "If the model is not improving for stopping_rounds, the training process will be stopped, for 'weight' stopping metric, stopping_rounds is fixed to be 1",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "100"
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "stopping_tolerance",
          "desc": "the model is considered as not improving, if the metric is not improved by tolerance over best metric in history. If metric is 'weight' and tolerance == 0, then early stop is disabled.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.001
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            }
          },
          "minorMax": -1
        },
        {
          "name": "report_metric",
          "desc": "Whether to report the value of stopping metric. Only effective if early stop is enabled. If this option is set to true, metric will be revealed and logged.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        },
        {
          "name": "use_high_precision_exp",
          "desc": "If you do not know the details of this parameter, please do not modify this parameter! If this option is true, glm training and prediction will use a high-precision exp approx, but there will be a large performance drop. Otherwise, use high performance exp approx, There will be no significant difference in model performance. However, prediction bias may occur if the model is exported to an external system for use.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "name": "exp_mode",
          "desc": "If you do not know the details of this parameter, please do not modify this parameter! Specify the mode of exp taylor approx, currently only supports 'taylor', 'pade' and 'prime' modes. The default value is 'taylor'. 'taylor': use taylor approx, variable precision and cost, higher exp_iters, higher cost. 'pade': use pade approx, high precision, high cost. 'prime': use prime approx, best precision, 3/4 cost of taylor (8 iter), only support for SEMI2K FM128 case. Although it has great presicion and performance inside valid domain, the approximation can be wildly inaccurate outside the valid domain. Suppose x -> exp(x), then valid domain is: x in ((47 - offset - 2fxp)/log_2(e), (125 - 2fxp - offset)/log_2(e)). That's why we need clamping x to this range. However, clamping action is expensive, so we need to set a reasonable offset to control the valid range of exp prime method, and avoid clamping for best performance.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "taylor"
            },
            "allowedValues": {
              "ss": [
                "pade",
                "taylor",
                "prime"
              ]
            }
          },
          "minorMin": 1,
          "minorMax": -1
        },
        {
          "name": "exp_iters",
          "desc": "If you do not know the details of this parameter, please do not modify this parameter! Specify the number of iterations of exp taylor approx, Only takes effect when using exp mode 'taylor'. Increasing this value will improve the accuracy of exp approx, but will quickly degrade performance.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "8"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "4"
            },
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "32"
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "exp_prime_offset",
          "desc": "If you do not know the details of this parameter, please do not modify this parameter! Specify the offset of exp prime approx, only takes effect when using exp mode 'prime'. control the valid range of exp prime method. Suppose x -> exp(x), then valid domain is: x in ((47 - offset - 2fxp)/log_2(e), (125 - 2fxp - offset)/log_2(e)) default to be 13.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "13"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          },
          "minorMin": 1,
          "minorMax": -1
        },
        {
          "name": "exp_prime_lower_bound_clamp",
          "desc": "If you do not know the details of this parameter, please do not modify this parameter! Specify whether to use lower bound for exp prime mode, only takes effect when using exp mode 'prime'. when calculating x -> exp(x), exp prime is only effective for x in ((47 - offset - 2fxp)/log_2(e), (125 - 2fxp - offset)/log_2(e)). If true, use clamp value below the lower bound, otherwise leave the value unchanged. lower bound is set to be (48 - offset - 2fxp)/log_2(e). Enable clamping will avoid large numerical errors when x < lower bound. Disable clamping will leave the value unchanged, which may cause large numerical errors when x < lower bound. However, clamping cost is very high, if we are certain x is in the valid range, it is recommended to disable clamping.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          },
          "minorMin": 1,
          "minorMax": -1
        },
        {
          "name": "exp_prime_higher_bound_clamp",
          "desc": "If you do not know the details of this parameter, please do not modify this parameter! Specify whether to use upper bound for exp prime mode, only takes effect when using exp mode 'prime'. when calculating x -> exp(x), exp prime is only effective for x in ((47 - offset - 2fxp)/log_2(e), (125 - 2fxp - offset)/log_2(e)). If true, use clamp value above the upper bound, otherwise leave the value unchanged. upper bound is set to be (125 - 2fxp - offset)/log_2(e). Enable clamping will avoid large numerical errors when x > upper bound. Disable clamping will leave the value unchanged, which may cause large numerical errors when x > upper bound. However, clamping cost is very high, if we are certain x is in the valid range, it is recommended to disable clamping.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMin": 1,
          "minorMax": -1
        },
        {
          "name": "report_weights",
          "desc": "If this option is set to true, model will be revealed and model details are visible to all parties",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "which features should be used for training.",
              "colMinCntInclusive": "1"
            },
            {
              "name": "offset",
              "desc": "Specify a column to use as the offset",
              "colMaxCntInclusive": "1"
            },
            {
              "name": "weight",
              "desc": "Specify a column to use for the observation weights",
              "colMaxCntInclusive": "1"
            },
            {
              "name": "label",
              "desc": "Label of train dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_model",
          "desc": "Output model.",
          "types": [
            "sf.model.ss_glm"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "report",
          "desc": "If report_weights is true, report model details",
          "types": [
            "sf.report"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "ml.train",
      "name": "ss_sgd_train",
      "version": "1.0.0",
      "desc": "Train both linear and logistic regression\nlinear models for vertical partitioning dataset with mini batch SGD training solver by using secret sharing.\n- SS-SGD is short for secret sharing SGD training.",
      "attrs": [
        {
          "name": "epochs",
          "desc": "The number of complete pass through the training data.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "learning_rate",
          "desc": "The step size at each iteration in one iteration.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          },
          "minorMax": -1
        },
        {
          "name": "batch_size",
          "desc": "The number of training examples utilized in one iteration.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "1024"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          },
          "minorMax": -1
        },
        {
          "name": "sig_type",
          "desc": "Sigmoid approximation type.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "t1"
            },
            "allowedValues": {
              "ss": [
                "real",
                "t1",
                "t3",
                "t5",
                "df",
                "sr",
                "mix"
              ]
            }
          },
          "minorMax": -1
        },
        {
          "name": "reg_type",
          "desc": "Regression type",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "logistic"
            },
            "allowedValues": {
              "ss": [
                "linear",
                "logistic"
              ]
            }
          },
          "minorMax": -1
        },
        {
          "name": "penalty",
          "desc": "The penalty(aka regularization term) to be used.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "None"
            },
            "allowedValues": {
              "ss": [
                "None",
                "l2"
              ]
            }
          },
          "minorMax": -1
        },
        {
          "name": "l2_norm",
          "desc": "L2 regularization term.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.5
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "eps",
          "desc": "If the change rate of weights is less than this threshold, the model is considered to be converged, and the training stops early. 0 to disable.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.001
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "report_weights",
          "desc": "If this option is set to true, model will be revealed and model details are visible to all parties",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "which features should be used for training.",
              "colMinCntInclusive": "1"
            },
            {
              "name": "label",
              "desc": "Label of train dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_model",
          "desc": "Output model.",
          "types": [
            "sf.model.ss_sgd"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "report",
          "desc": "If report_weights is true, report model details",
          "types": [
            "sf.report"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "ml.train",
      "name": "ss_xgb_train",
      "version": "1.0.0",
      "desc": "This method provides both classification and regression tree boosting (also known as GBDT, GBM)\nfor vertical partitioning dataset setting by using secret sharing.\n- SS-XGB is short for secret sharing XGB.\n- More details: https://arxiv.org/pdf/2005.08479.pdf",
      "attrs": [
        {
          "name": "num_boost_round",
          "desc": "Number of boosting iterations.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "max_depth",
          "desc": "Maximum depth of a tree.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "5"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "16"
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "learning_rate",
          "desc": "Step size shrinkage used in updates to prevent overfitting.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "objective",
          "desc": "Specify the learning objective.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "logistic"
            },
            "allowedValues": {
              "ss": [
                "linear",
                "logistic"
              ]
            }
          },
          "minorMax": -1
        },
        {
          "name": "reg_lambda",
          "desc": "L2 regularization term on weights.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 10000.0
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "subsample",
          "desc": "Subsample ratio of the training instances.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "colsample_by_tree",
          "desc": "Subsample ratio of columns when constructing each tree.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "sketch_eps",
          "desc": "This roughly translates into O(1 / sketch_eps) number of bins.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "base_score",
          "desc": "The initial prediction score of all instances, global bias.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {
              "f": -10.0
            },
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 10.0
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "seed",
          "desc": "Pseudorandom number generator seed.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "42"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "which features should be used for training.",
              "colMinCntInclusive": "1"
            },
            {
              "name": "label",
              "desc": "Label of train dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_model",
          "desc": "Output model.",
          "types": [
            "sf.model.ss_xgb"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "model",
      "name": "model_export",
      "version": "1.0.0",
      "desc": "The model_export component supports converting and\npackaging the rule files generated by preprocessing and\npostprocessing components, as well as the model files generated\nby model operators, into a Secretflow-Serving model package. The\nlist of components to be exported must contain exactly one model\ntrain or model predict component, and may include zero or\nmultiple preprocessing and postprocessing components.",
      "attrs": [
        {
          "name": "model_name",
          "desc": "model's name",
          "type": "AT_STRING",
          "atomic": {},
          "minorMax": -1
        },
        {
          "name": "model_desc",
          "desc": "Describe what the model does",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        },
        {
          "name": "input_datasets",
          "desc": "The input data IDs for all components to be exported. Their order must remain consistent with the sequence in which the components were executed.",
          "type": "AT_STRINGS",
          "atomic": {
            "listMaxLengthInclusive": "-1"
          },
          "minorMax": -1
        },
        {
          "name": "output_datasets",
          "desc": "The output data IDs for all components to be exported. Their order must remain consistent with the sequence in which the components were executed.",
          "type": "AT_STRINGS",
          "atomic": {
            "listMaxLengthInclusive": "-1"
          },
          "minorMax": -1
        },
        {
          "name": "component_eval_params",
          "desc": "The eval parameters (in JSON format) for all components to be exported. Their order must remain consistent with the sequence in which the components were executed.",
          "type": "AT_STRINGS",
          "atomic": {
            "listMaxLengthInclusive": "-1"
          },
          "minorMax": -1
        },
        {
          "name": "he_mode",
          "desc": "If enabled, it will export a homomorphic encryption model. Currently, only SGD and GLM models for two-party scenarios are supported.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_package",
          "desc": "output tar package uri",
          "types": [
            "sf.serving.model"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "report",
          "desc": "report dumped model's input schemas",
          "types": [
            "sf.report"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "postprocessing",
      "name": "score_card_transformer",
      "version": "1.0.0",
      "desc": "Transform the predicted result (a probability value) produced by the logistic regression model into a more understandable score (for example, a score of up to 1000 points)",
      "attrs": [
        {
          "name": "positive",
          "desc": "Value for positive cases.",
          "type": "AT_INT",
          "atomic": {
            "defaultValue": {
              "i64": "1"
            },
            "allowedValues": {
              "i64s": [
                "0",
                "1"
              ]
            }
          },
          "minorMax": -1
        },
        {
          "name": "predict_score_name",
          "type": "AT_STRING",
          "atomic": {
            "defaultValue": {
              "s": "predict_score"
            }
          },
          "minorMax": -1
        },
        {
          "name": "scaled_value",
          "desc": "Set a benchmark score that can be adjusted for specific business scenarios",
          "type": "AT_INT",
          "atomic": {
            "defaultValue": {
              "i64": "600"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          },
          "minorMax": -1
        },
        {
          "name": "odd_base",
          "desc": "the odds value at given score baseline, odds = p / (1-p)",
          "type": "AT_FLOAT",
          "atomic": {
            "defaultValue": {
              "f": 20.0
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          },
          "minorMax": -1
        },
        {
          "name": "pdo",
          "desc": "points to double the odds",
          "type": "AT_FLOAT",
          "atomic": {
            "defaultValue": {
              "f": 20.0
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          },
          "minorMax": -1
        },
        {
          "name": "min_score",
          "desc": "An integer of [0,999] is supported",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "999"
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "max_score",
          "desc": "An integer of [1,1000] is supported",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "1000"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "1000"
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "predict result table",
          "types": [
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "predict_name",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "output table",
          "types": [
            "sf.table.individual"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "preprocessing",
      "name": "binary_op",
      "version": "1.0.0",
      "desc": "Perform binary operation binary_op(f1, f2) and assign the result to f3, f3 can be new or old. Currently f1, f2 and f3 all belong to a single party.",
      "attrs": [
        {
          "name": "binary_op",
          "desc": "What kind of binary operation we want to do, currently only supports +, -, *, /",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "+"
            },
            "allowedValues": {
              "ss": [
                "+",
                "-",
                "*",
                "/"
              ]
            }
          },
          "minorMax": -1
        },
        {
          "name": "new_feature_name",
          "desc": "Name of the newly generated feature. If this feature already exists, it will be overwritten.",
          "type": "AT_STRING",
          "atomic": {},
          "minorMax": -1
        },
        {
          "name": "as_label",
          "desc": "If True, the generated feature will be marked as label in schema, otherwise it will be treated as Feature.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "attrs": [
            {
              "name": "f1",
              "desc": "Feature 1 to operate on.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            },
            {
              "name": "f2",
              "desc": "Feature 2 to operate on.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "Output vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "output_rule",
          "desc": "feature gen rule",
          "types": [
            "sf.rule.preprocessing"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "preprocessing",
      "name": "case_when",
      "version": "1.0.0",
      "desc": "case_when",
      "attrs": [
        {
          "name": "rules",
          "desc": "input CaseWhen rules",
          "type": "AT_CUSTOM_PROTOBUF",
          "customProtobufCls": "case_when_rules_pb2.CaseWhenRule",
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "output_dataset",
          "types": [
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "output_rule",
          "desc": "case when substitution rule",
          "types": [
            "sf.rule.preprocessing"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "preprocessing",
      "name": "cast",
      "version": "1.0.0",
      "desc": "For conversion between basic data types, such as converting float to string.",
      "attrs": [
        {
          "name": "astype",
          "desc": "single-choice, options available are string, integer, float",
          "type": "AT_UNION_GROUP",
          "union": {
            "defaultSelection": "integer"
          },
          "minorMax": -1
        },
        {
          "prefixes": [
            "astype"
          ],
          "name": "integer",
          "desc": "integer",
          "minorMax": -1
        },
        {
          "prefixes": [
            "astype"
          ],
          "name": "float",
          "desc": "float",
          "minorMax": -1
        },
        {
          "prefixes": [
            "astype"
          ],
          "name": "string",
          "desc": "string",
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "The input table",
          "types": [
            "sf.table.vertical"
          ],
          "attrs": [
            {
              "name": "columns",
              "desc": "Multiple-choice, options available are string, integer, float, boolean",
              "colMinCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "The output table",
          "types": [
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "output_rule",
          "desc": "The output rules",
          "types": [
            "sf.rule.preprocessing"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "preprocessing",
      "name": "feature_calculate",
      "version": "1.0.0",
      "desc": "Generate a new feature by performing calculations on an origin feature",
      "attrs": [
        {
          "name": "rules",
          "desc": "input CalculateOpRules rules",
          "type": "AT_CUSTOM_PROTOBUF",
          "customProtobufCls": "calculate_rules_pb2.CalculateOpRules",
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input vertical table",
          "types": [
            "sf.table.vertical"
          ],
          "attrs": [
            {
              "name": "features",
              "desc": "Feature(s) to operate on",
              "colMinCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "output_dataset",
          "types": [
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "output_rule",
          "desc": "feature calculate rule",
          "types": [
            "sf.rule.preprocessing"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "preprocessing",
      "name": "fillna",
      "version": "1.0.0",
      "desc": "Fill null/nan or other specificed outliers in dataset",
      "attrs": [
        {
          "name": "nan_is_null",
          "desc": "Whether floating-point NaN values are considered null, take effect with float columns",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          },
          "minorMax": -1
        },
        {
          "name": "float_outliers",
          "desc": "These outlier value are considered null, take effect with float columns",
          "type": "AT_FLOATS",
          "atomic": {
            "listMaxLengthInclusive": "-1",
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        },
        {
          "name": "int_outliers",
          "desc": "These outlier value are considered null, take effect with int columns",
          "type": "AT_INTS",
          "atomic": {
            "listMaxLengthInclusive": "-1",
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        },
        {
          "name": "str_outliers",
          "desc": "These outlier value are considered null, take effect with str columns",
          "type": "AT_STRINGS",
          "atomic": {
            "listMaxLengthInclusive": "-1",
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        },
        {
          "name": "str_fill_strategy",
          "desc": "Replacement strategy for str column. If \"most_frequent\", then replace missing using the most frequent value along each column. If \"constant\", then replace missing values with fill_value_str.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "constant"
            },
            "allowedValues": {
              "ss": [
                "constant",
                "most_frequent"
              ]
            }
          },
          "minorMax": -1
        },
        {
          "name": "fill_value_str",
          "desc": "For str type data. If method is 'constant' use this value for filling null.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        },
        {
          "name": "int_fill_strategy",
          "desc": "Replacement strategy for int column. If \"mean\", then replace missing values using the mean along each column. If \"median\", then replace missing values using the median along each column If \"most_frequent\", then replace missing using the most frequent value along each column. If \"constant\", then replace missing values with fill_value_int.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "constant"
            },
            "allowedValues": {
              "ss": [
                "mean",
                "median",
                "most_frequent",
                "constant"
              ]
            }
          },
          "minorMax": -1
        },
        {
          "name": "fill_value_int",
          "desc": "For int type data. If method is 'constant' use this value for filling null.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        },
        {
          "name": "float_fill_strategy",
          "desc": "Replacement strategy for float column. If \"mean\", then replace missing values using the mean along each column. If \"median\", then replace missing values using the median along each column If \"most_frequent\", then replace missing using the most frequent value along each column. If \"constant\", then replace missing values with fill_value_float.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "constant"
            },
            "allowedValues": {
              "ss": [
                "mean",
                "median",
                "most_frequent",
                "constant"
              ]
            }
          },
          "minorMax": -1
        },
        {
          "name": "fill_value_float",
          "desc": "For float type data. If method is 'constant' use this value for filling null.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        },
        {
          "name": "bool_fill_strategy",
          "desc": "Replacement strategy for bool column. If \"most_frequent\", then replace missing using the most frequent value along each column. If \"constant\", then replace missing values with fill_value_bool.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "constant"
            },
            "allowedValues": {
              "ss": [
                "constant",
                "most_frequent"
              ]
            }
          },
          "minorMax": -1
        },
        {
          "name": "fill_value_bool",
          "desc": "For bool type data. If method is 'constant' use this value for filling null.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "attrs": [
            {
              "name": "fill_na_features",
              "desc": "Features to fill."
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "Output vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "output_rule",
          "desc": "fill value rule",
          "types": [
            "sf.rule.preprocessing"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "preprocessing",
      "name": "onehot_encode",
      "version": "1.0.0",
      "desc": "onehot_encode",
      "attrs": [
        {
          "name": "drop",
          "desc": "drop unwanted category based on selection",
          "type": "AT_UNION_GROUP",
          "union": {
            "defaultSelection": "no_drop"
          },
          "minorMax": -1
        },
        {
          "prefixes": [
            "drop"
          ],
          "name": "no_drop",
          "desc": "do not drop",
          "minorMax": -1
        },
        {
          "prefixes": [
            "drop"
          ],
          "name": "first",
          "desc": "drop the first category in each feature.",
          "minorMax": -1
        },
        {
          "prefixes": [
            "drop"
          ],
          "name": "mode",
          "desc": "drop the mode category in each feature",
          "minorMax": -1
        },
        {
          "name": "min_frequency",
          "desc": "Specifies the minimum frequency below which a category will be considered infrequent, [0, 1), 0 disable",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            }
          },
          "minorMax": -1
        },
        {
          "name": "report_rules",
          "desc": "Whether to report rule details",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "attrs": [
            {
              "name": "features",
              "desc": "Features to encode."
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "output dataset",
          "types": [
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "output_rule",
          "desc": "onehot rule",
          "types": [
            "sf.rule.preprocessing"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "report",
          "desc": "report rules details if report_rules is true",
          "types": [
            "sf.report"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "preprocessing",
      "name": "sql_processor",
      "version": "1.0.0",
      "desc": "sql processor",
      "attrs": [
        {
          "name": "sql",
          "desc": "sql for preprocessing, for example SELECT a, b, a+b",
          "type": "AT_STRING",
          "atomic": {},
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input table",
          "types": [
            "sf.table.individual",
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "Output table",
          "types": [
            "sf.table.individual",
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "output_rule",
          "desc": "Output rule",
          "types": [
            "sf.rule.preprocessing"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "preprocessing",
      "name": "substitution",
      "version": "1.0.0",
      "desc": "unified substitution component",
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "input_rule",
          "desc": "Input preprocessing rules",
          "types": [
            "sf.rule.preprocessing",
            "sf.rule.binning"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "output_dataset",
          "types": [
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "preprocessing",
      "name": "vert_binning",
      "version": "1.0.0",
      "desc": "Generate equal frequency or equal range binning rules for vertical partitioning datasets.",
      "attrs": [
        {
          "name": "binning_method",
          "desc": "How to bin features with numeric types: \"quantile\"(equal frequency)/\"eq_range\"(equal range)",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "eq_range"
            },
            "allowedValues": {
              "ss": [
                "eq_range",
                "quantile"
              ]
            }
          },
          "minorMax": -1
        },
        {
          "name": "bin_num",
          "desc": "Max bin counts for one features.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "2"
            },
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "report_rules",
          "desc": "Whether report binning rules.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "which features should be binned.",
              "colMinCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "Output vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "output_rule",
          "desc": "Output bin rule.",
          "types": [
            "sf.rule.binning"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "report",
          "desc": "report rules details if report_rules is true",
          "types": [
            "sf.report"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "preprocessing",
      "name": "vert_woe_binning",
      "version": "1.0.0",
      "desc": "Generate Weight of Evidence (WOE) binning rules for vertical partitioning datasets.",
      "attrs": [
        {
          "name": "secure_device_type",
          "desc": "Use SPU(Secure multi-party computation or MPC) or HEU(Homomorphic encryption or HE) to secure bucket summation.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "spu"
            },
            "allowedValues": {
              "ss": [
                "spu",
                "heu"
              ]
            }
          },
          "minorMax": -1
        },
        {
          "name": "binning_method",
          "desc": "How to bin features with numeric types: \"quantile\"(equal frequency)/\"chimerge\"(ChiMerge from AAAI92-019: https://www.aaai.org/Papers/AAAI/1992/AAAI92-019.pdf)/\"eq_range\"(equal range)",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "quantile"
            },
            "allowedValues": {
              "ss": [
                "quantile",
                "chimerge",
                "eq_range"
              ]
            }
          },
          "minorMax": -1
        },
        {
          "name": "bin_num",
          "desc": "Max bin counts for one features.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          },
          "minorMax": -1
        },
        {
          "name": "positive_label",
          "desc": "Which value represent positive value in label.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "1"
            }
          },
          "minorMax": -1
        },
        {
          "name": "chimerge_init_bins",
          "desc": "Max bin counts for initialization binning in ChiMerge.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "100"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "2"
            }
          },
          "minorMax": -1
        },
        {
          "name": "chimerge_target_bins",
          "desc": "Stop merging if remaining bin counts is less than or equal to this value.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "2"
            },
            "lowerBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "chimerge_target_pvalue",
          "desc": "Stop merging if biggest pvalue of remaining bins is greater than this value.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          },
          "minorMax": -1
        },
        {
          "name": "report_rules",
          "desc": "Whether report binning rules.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "which features should be binned. WARNING: WOE won't be effective for features with enumeration count <=2.",
              "colMinCntInclusive": "1"
            },
            {
              "name": "label",
              "desc": "Label of input data.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "Output vertical table.",
          "types": [
            "sf.table.vertical"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "output_rule",
          "desc": "Output WOE rule.",
          "types": [
            "sf.rule.binning"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "report",
          "desc": "report rules details if report_rules is true",
          "types": [
            "sf.report"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "stats",
      "name": "groupby_statistics",
      "version": "1.0.0",
      "desc": "Get a groupby of statistics, like pandas groupby statistics.\nCurrently only support VDataframe.",
      "attrs": [
        {
          "name": "aggregation_config",
          "desc": "input groupby aggregation config",
          "type": "AT_CUSTOM_PROTOBUF",
          "customProtobufCls": "groupby_aggregation_config_pb2.GroupbyAggregationConfig",
          "minorMax": -1
        },
        {
          "name": "max_group_size",
          "desc": "The maximum number of groups allowed",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10000"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "10001"
            }
          },
          "minorMax": -1
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input table.",
          "types": [
            "sf.table.vertical",
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "by",
              "desc": "by what columns should we group the values, encode values into int or str before groupby or else numeric errors may occur",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "4"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "report",
          "desc": "Output groupby statistics report.",
          "types": [
            "sf.report"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "stats",
      "name": "ss_pearsonr",
      "version": "1.0.0",
      "desc": "Calculate Pearson's product-moment correlation coefficient for vertical partitioning dataset\nby using secret sharing.\n- For large dataset(large than 10w samples & 200 features), recommend to use [Ring size: 128, Fxp: 40] options for SPU device.",
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical",
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "Specify which features to calculate correlation coefficient with. If empty, all features will be used"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "report",
          "desc": "Output Pearson's product-moment correlation coefficient report.",
          "types": [
            "sf.report"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "stats",
      "name": "ss_vif",
      "version": "1.0.0",
      "desc": "Calculate Variance Inflation Factor(VIF) for vertical partitioning dataset\nby using secret sharing.\n- For large dataset(large than 10w samples & 200 features), recommend to use [Ring size: 128, Fxp: 40] options for SPU device.",
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical",
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "Specify which features to calculate VIF with. If empty, all features will be used."
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "report",
          "desc": "Output Variance Inflation Factor(VIF) report.",
          "types": [
            "sf.report"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "stats",
      "name": "stats_psi",
      "version": "1.0.0",
      "desc": "population stability index.",
      "inputs": [
        {
          "name": "input_base_ds",
          "desc": "Input base vertical table.",
          "types": [
            "sf.table.vertical",
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "which features should be binned.",
              "colMinCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "input_test_ds",
          "desc": "Input test vertical table.",
          "types": [
            "sf.table.vertical",
            "sf.table.individual"
          ],
          "variableMax": -1,
          "minorMax": -1
        },
        {
          "name": "input_rule",
          "desc": "Input bin rule.",
          "types": [
            "sf.rule.binning"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "report",
          "desc": "Output population stability index.",
          "types": [
            "sf.report"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    },
    {
      "domain": "stats",
      "name": "table_statistics",
      "version": "1.0.2",
      "desc": "Get a table of statistics,\nincluding each column's\n1. datatype\n2. total_count\n3. count\n4. count_na\n5. na_ratio\n6. min\n7. max\n8. mean\n9. var\n10. std\n11. sem\n12. skewness\n13. kurtosis\n14. q1\n15. q2\n16. q3\n17. moment_2\n18. moment_3\n19. moment_4\n20. central_moment_2\n21. central_moment_3\n22. central_moment_4\n23. sum\n24. sum_2\n25. sum_3\n26. sum_4\n- moment_2 means E[X^2].\n- central_moment_2 means E[(X - mean(X))^2].\n- sum_2 means sum(X^2).\nAll of the object or string class columns will not be included in the above statistics, but in a separate report.\nThe second report is a table of the object or string class columns.\nNote that please do not include individual information (like address, phone number, etc.) for table statistics.\nThe categorical report will be with the following columns:\n1. column dtype (the data type of the column)\n2. count (the number of non-null values)\n3. nunique (the number of unique values in this column)\nif no numeric or categorical columns, the report will be dummy report.",
      "inputs": [
        {
          "name": "input_ds",
          "desc": "Input table.",
          "types": [
            "sf.table.vertical",
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "features",
              "desc": "perform statistics on these columns",
              "colMinCntInclusive": "1"
            }
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ],
      "outputs": [
        {
          "name": "report",
          "desc": "Output table statistics report.",
          "types": [
            "sf.report"
          ],
          "variableMax": -1,
          "minorMax": -1
        }
      ]
    }
  ]
}